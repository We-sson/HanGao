<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="24.05.0.0">
<procedure name="main">
<interface/>
<body>
<c>* </c>
<c>* This example shows how to calibrate a stereo setup of two</c>
<c>* telecentric line scan cameras. Additionally, the calibration</c>
<c>* results are used for a stereo reconstruction.</c>
<c>* </c>
<c>* 本示例演示了如何校准由两个</c>
<c>* 远心线扫描相机。此外，校准</c>
<c>* 结果用于立体重建。</c>
<c>* Initialize visualization.</c>
<l>dev_close_window ()</l>
<l>dev_update_off ()</l>
<c>* </c>
<c></c>
<l>I := 1</l>
<l>Image_L:='C:/Users/H/MVS/Data/L/'</l>
<l>Image_R:='C:/Users/H/MVS/Data/R/'</l>
<c></c>
<l>* User_Name:='C:/Users/zhiwei2.he/source/repos/We-sson/'</l>
<l>User_Name:='C:/Users/H/source/repos/'</l>
<c></c>
<l>stop()</l>
<c></c>
<c></c>
<c></c>
<l>read_image (ImageBack, Image_L+'1.tif')</l>
<l>read_image (ImageFront, Image_R+'1.tif')</l>
<l>* read_image (ImageFront, 'C:/Users/zhiwei2.he/MVS/Data/L/1.tif')</l>
<l>* read_image (ImageBack, 'C:/Users/zhiwei2.he/MVS/Data/R/1.tif')</l>
<l>get_image_size (ImageBack, WidthBack, HeightBack)</l>
<l>get_image_size (ImageFront, WidthFront, HeightFront)</l>
<c>* </c>
<l>dev_open_window (0, 0, 600, 450, 'black', WindowHandle)</l>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<l>dev_disp_intro_text ()</l>
<l>* stop ()</l>
<l>dev_disp_calibration_text ()</l>
<l>* stop ()</l>
<l>dev_close_window ()</l>
<c>* </c>
<l>WindowSizeFactor1 := 6</l>
<l>dev_open_window (0, 0, WidthBack / WindowSizeFactor1, HeightBack / WindowSizeFactor1, 'black', WindowHandle1)</l>
<l>set_display_font (WindowHandle1, 14, 'mono', 'true', 'false')</l>
<l>dev_open_window (0, WidthBack / WindowSizeFactor1 + 12, WidthFront / WindowSizeFactor1, HeightFront / WindowSizeFactor1, 'black', WindowHandle2)</l>
<l>set_display_font (WindowHandle2, 14, 'mono', 'true', 'false')</l>
<c>* </c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* </c>
<c>* 1. Calibrate the stereo setup.</c>
<c>* </c>
<c>* Set the initial values for the internal camera parameters.</c>
<c>* 校准立体声设置。</c>
<c>* </c>
<c>* 设置摄像机内部参数的初始值。</c>
<l>* read_cam_par ('C:/Users/zhiwei2.he/Source/repos/We-sson/HanGao/HanGao_Base/bin/x64/Debug/net6.0-windows/Calibration_File/DA0651471.dat', StartCamParamBack)</l>
<l>* read_cam_par ('C:/Users/zhiwei2.he/Source/repos/We-sson/HanGao/HanGao_Base/bin/x64/Debug/net6.0-windows/Calibration_File/DA0651573.dat', StartCamParamFront)</l>
<l>gen_cam_par_area_scan_polynomial (0.016, 0, 0, 0, 0, 0, 1.85e-06, 1.85e-06, WidthBack / 2, HeightBack/2, WidthBack, HeightBack, StartCamParam_L)</l>
<l>gen_cam_par_area_scan_polynomial (0.016, 0, 0, 0, 0, 0, 1.85e-06, 1.85e-06, WidthFront / 2, HeightFront/2, WidthFront, HeightFront, StartCamParam_R)</l>
<l>* gen_cam_par_line_scan_telecentric_division (0.228, 0, 7.0e-6, 7.0e-6, WidthBack / 2, 0, WidthBack, HeightBack, 0, 2.7e-5, 0, StartCamParamBack)</l>
<l>* gen_cam_par_line_scan_telecentric_division (0.268, 0, 7.0e-6, 7.0e-6, WidthFront / 2, 0, WidthFront, HeightFront, 0, 2.7e-5, 0, StartCamParamFront)</l>
<c>* </c>
<c>* Create a calibration data model in which all calibration data</c>
<c>* including the image coordinates of the calibration marks and</c>
<c>* the observation poses of the calibration plate will be</c>
<c>* accumulated.</c>
<c>* 创建校准数据模型，其中包括所有校准数据</c>
<c>* 包括校准标记的图像坐标和</c>
<c>* 校准板的观测位置。</c>
<c>* 积累。</c>
<l>create_calib_data ('calibration_object', 2, 1, CalibDataID)</l>
<l>set_calib_data_cam_param (CalibDataID, 0, [], StartCamParam_L)</l>
<l>set_calib_data_cam_param (CalibDataID, 1, [], StartCamParam_R)</l>
<l>* CalibObjDescr := 'C:/Users/zhiwei2.he/Source/repos/We-sson/HanGao/Halcon_SDK/Calibration_File/CalTabFile/27_31_0.0015_calplate.cpd'</l>
<c></c>
<l>CalibObjDescr := User_Name+'HanGao/Halcon_SDK/Calibration_File/CalTabFile/27_31_0.0015_calplate.cpd'</l>
<c></c>
<l>set_calib_data_calib_object (CalibDataID, 0, CalibObjDescr)</l>
<c>* As the two cameras are mounted rigidly and stationary and the</c>
<c>* object is moved linearly in front of the cameras, only one</c>
<c>* common motion vector needs to be determined.</c>
<c>* 由于两台照相机固定不动，而物体在照相机前方线性移动。</c>
<c>* 物体在摄像机前线性移动，因此只需确定一个</c>
<c>* 需要确定一个共同的运动矢量。</c>
<l>* set_calib_data (CalibDataID, 'model', 'general', 'common_motion_vector', 'true')</l>
<l>set_calib_data (CalibDataID, 'model', 'general', 'optimization_method', 'stochastic')</l>
<c>* </c>
<c>* Start the loop over the calibration images.</c>
<c>* 开始循环校准图像。</c>
<c></c>
<l>gen_empty_obj (ImagesBack)</l>
<l>gen_empty_obj (ImagesFront)</l>
<c>* 读取本地文件</c>
<l>list_files (Image_L, ['files','follow_links'], Image_L_Files)</l>
<l>tuple_regexp_select (Image_L_Files, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$','ignore_case'], ImagesBackFiles)</l>
<l>list_files (Image_R, ['files','follow_links'], Image_R_Files)</l>
<l>tuple_regexp_select (Image_R_Files, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$','ignore_case'], ImagesFrontFiles)</l>
<c></c>
<l>NumImages := |Image_L_Files|</l>
<l>for I := 0 to |ImagesBackFiles|-1 by 1</l>
<c>    * Read the calibration images.</c>
<c>    * 读取校准图像。</c>
<l>    read_image (Image_L_Caib, Image_L_Files[I])</l>
<l>    read_image (Image_R_Caib, Image_R_Files[I])</l>
<c>    * Find the calibration plate and store observations</c>
<c>    * in the calibration data model.</c>
<c>    * 找到校准板并将观测数据</c>
<c>    * 在校准数据模型中。</c>
<l>    find_calib_object (Image_L_Caib, CalibDataID, 0, 0, I, 'sigma', 1.5)</l>
<l>    find_calib_object (Image_R_Caib, CalibDataID, 1, 0, I, 'sigma', 1.5)</l>
<c>    * Visualize the extracted calibration marks.</c>
<c>    * 可视化提取的校准标记。</c>
<l>    get_calib_data_observ_contours (ContoursBack, CalibDataID, 'marks', 0, 0, I)</l>
<l>    dev_set_window (WindowHandle1)</l>
<l>    dev_display (Image_L_Caib)</l>
<l>    dev_display (ContoursBack)</l>
<l>    dev_disp_text ('Camera 0 (Back): Calibration image ' + (I + 1) + ' of ' + NumImages, 'window', 'top', 'left', 'black', [], [])</l>
<l>    get_calib_data_observ_contours (ContoursFront, CalibDataID, 'marks', 1, 0, I)</l>
<l>    dev_set_window (WindowHandle2)</l>
<l>    dev_display (Image_R_Caib)</l>
<l>    dev_display (ContoursFront)</l>
<l>    get_calib_data_observ_pose (CalibDataID, 0, 0, I, Cam0_P_Obj)</l>
<l>    dev_disp_text ('Camera 1 (Front): Calibration image ' + (I + 1) + ' of ' + NumImages, 'window', 'top', 'left', 'black', [], [])</l>
<l>endfor</l>
<c>* Perform the actual calibration.</c>
<c>* 进行实际校准。</c>
<l>calibrate_cameras (CalibDataID, Errors)</l>
<l>stop()</l>
<c></c>
<c>* Get the calibration results.</c>
<l>get_calib_data (CalibDataID, 'camera', 0, 'params', CamParam_L)</l>
<l>get_calib_data (CalibDataID, 'camera', 1, 'params', CamParam_R)</l>
<l>dev_set_window (WindowHandle1)</l>
<l>* dev_disp_calibration_results (CalibDataID)</l>
<l>dev_set_window (WindowHandle2)</l>
<l>dev_disp_text_calibration_error ()</l>
<l>stop ()</l>
<c>* </c>
<c>* 2. Check the calibration results with help of the residuals.</c>
<c>* </c>
<c>* Scaling factor for visualization of residuals.</c>
<c>* 2. 借助残差检查校准结果。</c>
<c>* </c>
<c>* 可视化残差的缩放因子。</c>
<l>ResScale := 50.0</l>
<c>* Loop over some calibration images.</c>
<c>* 循环播放一些校准图像。</c>
<l>NumImagesToDisplay := 4</l>
<l>for I := 0 to NumImagesToDisplay - 1 by 1</l>
<c>    * Calculate and display residuals for camera 0 (Back).</c>
<l>    dev_set_window (WindowHandle1)</l>
<l>    read_image (ImageBack, ImagesBackFiles[I])</l>
<l>    dev_display (ImageBack)</l>
<l>    calculate_and_display_residuals (CalibDataID, 0, I, ResScale, ResRowBack, ResColBack)</l>
<c>    * </c>
<c>    * Calculate and display residuals for camera 1 (Front).</c>
<l>    dev_set_window (WindowHandle2)</l>
<l>    read_image (ImageFront, ImagesFrontFiles[I])</l>
<l>    dev_display (ImageFront)</l>
<l>    calculate_and_display_residuals (CalibDataID, 1, I, ResScale, ResRowFront, ResColFront)</l>
<l>    dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>*     stop ()</l>
<l>endfor</l>
<c>* </c>
<l>dev_open_window (0, 0, 600, 450, 'black', WindowHandle)</l>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<l>dev_disp_residuals ()</l>
<l>stop ()</l>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_close_window ()</l>
<l>dev_set_window (WindowHandle2)</l>
<l>dev_close_window ()</l>
<c>* </c>
<c>* 3. Perform a stereo reconstruction using the stereo model.</c>
<c>* 使用立体模型进行立体重建。</c>
<c>* </c>
<l>dev_disp_reconstruction_text ()</l>
<l>stop ()</l>
<c></c>
<c>* </c>
<c>* Create the stereo model.</c>
<c>* 创建立体模型。</c>
<l>* write_calib_data (CalibDataID, 'C:/Users/zhiwei2.he/source/repos/We-sson/HanGao/Halcon_SDK/Halcon样图测试/立体视觉/Two_Calib.ccd')</l>
<l>write_calib_data (CalibDataID, 'C:/Users/H/source/repos/HanGao/Halcon_SDK/Halcon样图测试/立体视觉/Two_Calib.ccd')</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>stop()</l>
<l>dev_close_window ()</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="gen_contour_calib_marks">
<interface>
<oo>
<par name="ProjMarkContours" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="X" base_type="ctrl" dimension="0"/>
<par name="Y" base_type="ctrl" dimension="0"/>
<par name="Z" base_type="ctrl" dimension="0"/>
<par name="Radius" base_type="ctrl" dimension="0"/>
<par name="CalibObjPose" base_type="ctrl" dimension="0"/>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Create circle contours for the calibration marks.</c>
<l>R := gen_tuple_const(|X|,Radius)</l>
<l>gen_circle_contour_xld (ContCircle, Y, X, R, 0, 6.28318, 'positive', Radius / 20.0)</l>
<l>count_obj (ContCircle, NumMarks)</l>
<l>pose_to_hom_mat3d (CalibObjPose, HomMat3D)</l>
<l>gen_empty_obj (ProjMarkContours)</l>
<c>* Project the circle contours into the image with the current</c>
<c>* calibrated pose of the calibration plate.</c>
<l>for Index := 1 to NumMarks by 1</l>
<l>    select_obj (ContCircle, Contour, Index)</l>
<l>    get_contour_xld (Contour, Y, X)</l>
<l>    affine_trans_point_3d (HomMat3D, X, Y, gen_tuple_const(|X|,0), XC, YC, ZC)</l>
<l>    project_3d_point (XC, YC, ZC, CameraParam, Row, Column)</l>
<l>    gen_contour_polygon_xld (ContourMark, Row, Column)</l>
<l>    concat_obj (ProjMarkContours, ContourMark, ProjMarkContours)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_contour_calib_marks">
<parameters>
<parameter id="CalibObjPose"/>
<parameter id="CameraParam"/>
<parameter id="ProjMarkContours"/>
<parameter id="Radius"/>
<parameter id="X"/>
<parameter id="Y"/>
<parameter id="Z"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_intro_text">
<interface/>
<body>
<l>Text := 'This example shows how to calibrate a stereo setup of two telecentric'</l>
<l>Text[1] := 'line scan cameras. '</l>
<l>Text[2] := 'Additionally, the calibration results are used for a stereo'</l>
<l>Text[3] := 'reconstruction.'</l>
<l>dev_clear_window ()</l>
<l>dev_disp_text (Text, 'window', 12, 12, 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_intro_text">
<parameters/>
</docu>
</procedure>
<procedure name="dev_disp_calibration_text">
<interface/>
<body>
<l>Text := 'First, we calibrate the stereo setup.'</l>
<l>Text[1] := ''</l>
<l>Text[2] := 'In this case, the cameras were mounted firmly and the object was moved'</l>
<l>Text[3] := 'on a linear drive below.'</l>
<l>Text[4] := ''</l>
<l>Text[5] := 'The cameras were aligned along-track:'</l>
<l>Text[6] := 'one camera looking from the back to the front (camera 0, \'Back\'),'</l>
<l>Text[7] := 'one camera looking from the front to the back (camera 1, \'Front\').'</l>
<l>dev_clear_window ()</l>
<l>dev_disp_text (Text, 'window', 12, 12, 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_calibration_text">
<parameters/>
</docu>
</procedure>
<procedure name="dev_disp_calibration_results">
<interface>
<ic>
<par name="CalibDataID" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Get the calibration results</c>
<l>get_calib_data (CalibDataID, 'model', 'general', 'camera_calib_error', Errors)</l>
<l>get_calib_data (CalibDataID, 'camera', 0, 'params', CamParamBack)</l>
<l>get_calib_data (CalibDataID, 'camera', 0, 'params_labels', CamParamLabelsBack)</l>
<l>get_calib_data (CalibDataID, 'camera', 1, 'params', CamParamFront)</l>
<l>get_calib_data (CalibDataID, 'camera', 1, 'params_labels', CamParamLabelsFront)</l>
<l>get_calib_data (CalibDataID, 'camera', 1, 'pose', Back_P_Front)</l>
<l>pose_invert (Back_P_Front, Front_P_Back)</l>
<c>* </c>
<l>Text := 'Calibration results:'</l>
<l>Text[1] := ''</l>
<l>Text[2] := 'Calibration error:'</l>
<l>Text[3] := (Errors$'.2f') + ' px'</l>
<l>Text[4] := ''</l>
<l>Text[5] := 'Camera parameters:'</l>
<l>dev_clear_window ()</l>
<l>dev_disp_text (Text, 'window', 12, 12, 'white', 'box', 'false')</l>
<c>* </c>
<c>* Specify the format, scale, and unit of the elements of</c>
<c>* the camera parameters.</c>
<l>Format := ['', '10.5f', '7.2f', '7.2f', '7.2f', '7.2f', '7.2f', 'd', 'd', '7.2f', '7.2f', '7.2f']</l>
<l>Scale := [1.0, 1.0, 1.0, 1e6, 1e6, 1.0, 1.0, 1.0, 1.0, 1e6, 1e6, 1e6]</l>
<l>Unit := ['', '', '', ' um/px', ' um/px', ' px', ' px', ' px', ' px', ' um/px', ' um/px', ' um/px']</l>
<c>* </c>
<c>* Display camera parameters.</c>
<c>* Camera 0:</c>
<l>Text := 'Camera 0:'</l>
<l>for Index := 1 to |CamParamBack| - 1 by 1</l>
<l>    if (CamParamLabelsBack[Index] == 'image_width' or CamParamLabelsBack[Index] == 'image_height' or CamParamLabelsBack[Index] == 'p1' or CamParamLabelsBack[Index] == 'p2')</l>
<l>        continue</l>
<l>    endif</l>
<l>    Text := [Text,CamParamLabelsBack[Index]$'-13' + ' = ' + (CamParamBack[Index] * Scale[Index])$Format[Index] + Unit[Index]]</l>
<l>endfor</l>
<l>dev_disp_text (Text, 'window', 120, 22, 'white', 'box', 'false')</l>
<c>* Camera 1:</c>
<l>Text := 'Camera 1:'</l>
<l>for Index := 1 to |CamParamFront| - 1 by 1</l>
<l>    if (CamParamLabelsFront[Index] == 'image_width' or CamParamLabelsFront[Index] == 'image_height' or CamParamLabelsFront[Index] == 'p1' or CamParamLabelsFront[Index] == 'p2')</l>
<l>        continue</l>
<l>    endif</l>
<l>    Text := [Text,CamParamLabelsFront[Index]$'-13' + ' = ' + (CamParamFront[Index] * Scale[Index])$Format[Index] + Unit[Index]]</l>
<l>endfor</l>
<l>dev_disp_text (Text, 'window', 320, 22, 'white', 'box', 'false')</l>
<c>* </c>
<c>* Display relative pose.</c>
<l>Format := ['8.4f', '8.4f', '8.4f', '8.4f', '8.4f', '8.4f']</l>
<l>Unit := [' m', ' m', ' m', ' deg', ' deg', ' deg']</l>
<l>Text := 'Pose of camera 1 relative to camera 0:'</l>
<l>for Index := 0 to |Back_P_Front| - 2 by 1</l>
<l>    Text := [Text,Back_P_Front[Index]$Format[Index] + Unit[Index]]</l>
<l>endfor</l>
<l>dev_disp_text (Text, 'window', 520, 12, 'white', 'box', 'false')</l>
<l>return ()</l>
</body>
<docu id="dev_disp_calibration_results">
<parameters>
<parameter id="CalibDataID"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_text_calibration_error">
<interface/>
<body>
<l>Text := 'The resulting calibration error of over 0.5 px'</l>
<l>Text[1] := 'is rather high.'</l>
<l>Text[2] := ''</l>
<l>Text[3] := 'To check if there are systematic variations'</l>
<l>Text[4] := 'that might explain this, we have a look at'</l>
<l>Text[5] := 'the residuals:'</l>
<l>Text[6] := 'We compare the observed calibration mark'</l>
<l>Text[7] := 'centers with the projected mark centers.'</l>
<l>Text[8] := ''</l>
<l>Text[9] := 'In the following, we will show the residuals'</l>
<l>Text[10] := 'for a few of the calibration images.'</l>
<l>dev_clear_window ()</l>
<l>dev_disp_text (Text, 'window', 12, 12, 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_text_calibration_error">
<parameters/>
</docu>
</procedure>
<procedure name="dev_disp_reconstruction_text">
<interface/>
<body>
<l>Text := 'Now, we use the calibration results to reconstruct a 3D scene.'</l>
<l>Text[1] := ''</l>
<l>Text[2] := 'Here, we use a stereo model. This approach could be extended'</l>
<l>Text[3] := 'to use more than two cameras.'</l>
<l>Text[4] := 'Alternatively, when working with two cameras, it would also be '</l>
<l>Text[5] := 'possible to use the operators gen_binocular_rectification_map,'</l>
<l>Text[6] := 'map_image, binocular_disparity and disparity_to_xyz.'</l>
<l>dev_clear_window ()</l>
<l>dev_disp_text (Text, 'window', 12, 12, 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_reconstruction_text">
<parameters/>
</docu>
</procedure>
<procedure name="calculate_and_display_residuals">
<interface>
<ic>
<par name="CalibDataID" base_type="ctrl" dimension="0"/>
<par name="CameraIdx" base_type="ctrl" dimension="0"/>
<par name="I" base_type="ctrl" dimension="0"/>
<par name="ResScale" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ResRow" base_type="ctrl" dimension="0"/>
<par name="ResCol" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Get calibration information.</c>
<l>get_calib_data (CalibDataID, 'calib_obj', 0, 'x', X)</l>
<l>get_calib_data (CalibDataID, 'calib_obj', 0, 'y', Y)</l>
<l>get_calib_data (CalibDataID, 'calib_obj', 0, 'z', Z)</l>
<l>get_calib_data (CalibDataID, 'camera', CameraIdx, 'params', CamParam)</l>
<l>get_calib_data (CalibDataID, 'camera', CameraIdx, 'pose', World_P_Cam)</l>
<l>get_calib_data (CalibDataID, 'calib_obj_pose', [0,I], 'pose', World_P_Obj)</l>
<l>pose_invert (World_P_Cam, Cam_P_World)</l>
<l>pose_compose (Cam_P_World, World_P_Obj, Cam_P_Obj)</l>
<c>* Radius of the calibration marks (according to description file).</c>
<l>Radius := 0.000645161290322581</l>
<c>* Calculate the projection of the calibration marks.</c>
<l>gen_contour_calib_marks (ProjMarkContours, X, Y, Z, Radius, Cam_P_Obj, CamParam)</l>
<l>dev_set_color ('green')</l>
<l>dev_set_line_width (1)</l>
<l>dev_display (ProjMarkContours)</l>
<c>* Get the image coordinates of the observed calibration mark centers.</c>
<l>get_calib_data_observ_points (CalibDataID, CameraIdx, 0, I, ObsRow, ObsCol, ObsIndex, Pose)</l>
<c>* Calculate the image coordinates of the projected calibration mark</c>
<c>* centers and select the visible marks.</c>
<l>pose_to_hom_mat3d (Cam_P_Obj, Cam_H_Object)</l>
<l>affine_trans_point_3d (Cam_H_Object, X, Y, Z, CX, CY, CZ)</l>
<l>project_3d_point (CX, CY, CZ, CamParam, ProjRow, ProjCol)</l>
<l>ProjRowSel := ProjRow[ObsIndex]</l>
<l>ProjColumnSel := ProjCol[ObsIndex]</l>
<c>* Calculate the residuals.</c>
<l>ResRow := ProjRowSel - ObsRow</l>
<l>ResCol := ProjColumnSel - ObsCol</l>
<c>* Visualize the residuals.</c>
<l>gen_empty_obj (ResContours)</l>
<l>for IndexM := 0 to |ResRow| - 1 by 1</l>
<l>    gen_contour_polygon_xld (ResContour, [ObsRow[IndexM],ObsRow[IndexM] + ResScale * ResRow[IndexM]], [ObsCol[IndexM],ObsCol[IndexM] + ResScale * ResCol[IndexM]])</l>
<l>    concat_obj (ResContours, ResContour, ResContours)</l>
<l>endfor</l>
<l>dev_set_color ('red')</l>
<l>dev_set_line_width (2)</l>
<l>dev_display (ResContours)</l>
<l>Text := 'Camera ' + CameraIdx + ':'</l>
<l>Text[1] := 'Reprojection of calibration mark contours'</l>
<l>Text[2] := 'and residuals in image ' + (I + 1)</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="calculate_and_display_residuals">
<parameters>
<parameter id="CalibDataID"/>
<parameter id="CameraIdx"/>
<parameter id="I"/>
<parameter id="ResCol"/>
<parameter id="ResRow"/>
<parameter id="ResScale"/>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_residuals">
<interface/>
<body>
<l>Text := 'In the images, we could see that the direction of the residuals'</l>
<l>Text[1] := 'mainly corresponds to the direction of the movement vector.'</l>
<l>Text[2] := 'Furthermore, in certain image parts, the residuals are slightly'</l>
<l>Text[3] := 'bigger than in other image parts. This behavior seems to be periodic'</l>
<l>Text[4] := 'with the turns of the used linear drive.'</l>
<l>Text[5] := 'The same behavior can be observed for all calibration images.'</l>
<l>Text[6] := 'All this suggests that the actual motion vector is not perfectly'</l>
<l>Text[7] := 'constant due to mechanical limitations.'</l>
<l>Text[8] := ''</l>
<l>Text[9] := 'These systematic variations cause the rather high calibration error.'</l>
<l>dev_clear_window ()</l>
<l>dev_disp_text (Text, 'window', 12, 12, 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_residuals">
<parameters/>
</docu>
</procedure>
<procedure name="max_abs_image">
<interface>
<io>
<par name="Image1" base_type="iconic" dimension="0"/>
<par name="Image2" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="MaxImage" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* Combine two images by always choosing the</c>
<c>* maximum absolute gray value of each pixel</c>
<c>* for the output image.</c>
<l>abs_image (Image1, ImageAbs1)</l>
<l>abs_image (Image2, ImageAbs2)</l>
<c></c>
<l>dyn_threshold (ImageAbs1, ImageAbs2, Region1Greater, 0, 'light')</l>
<l>reduce_domain (Image1, Region1Greater, Image1Reduced)</l>
<l>paint_gray (Image1Reduced, Image2, MaxImage)</l>
<l>return ()</l>
</body>
<docu id="max_abs_image">
<parameters>
<parameter id="Image1"/>
<parameter id="Image2"/>
<parameter id="MaxImage"/>
</parameters>
</docu>
</procedure>
<procedure name="derivate_image">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DerivativeX" base_type="iconic" dimension="0"/>
<par name="DerivativeY" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* Calculate a simple derivate in x and y direction</c>
<l>convert_image_type (Image, ImageConverted, 'real')</l>
<l>convol_image (ImageConverted, DerivativeY, [3, 1, 1, -1, 0, 1], 'mirrored')</l>
<l>convol_image (ImageConverted, DerivativeX, [1, 3, 1, -1, 0, 1], 'mirrored')</l>
<l>return ()</l>
</body>
<docu id="derivate_image">
<parameters>
<parameter id="DerivativeX"/>
<parameter id="DerivativeY"/>
<parameter id="Image"/>
</parameters>
</docu>
</procedure>
<procedure name="create_hdr_image">
<interface>
<io>
<par name="Image1" base_type="iconic" dimension="0"/>
<par name="Image2" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="HDR" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* Calculate derivatives in x and y direction</c>
<c>* 计算 x 和 y 方向的导数</c>
<l>derivate_image (Image1, X1, Y1)</l>
<l>derivate_image (Image2, X2, Y2)</l>
<c>* Combine maximum absolute gradients</c>
<c>* 合并最大绝对梯度</c>
<l>max_abs_image (X1, X2, MaxX)</l>
<l>max_abs_image (Y1, Y2, MaxY)</l>
<c></c>
<c>* Transform combined image back to spatial domain</c>
<c>* 将组合图像转换回空间域</c>
<l>real_to_vector_field (MaxY, MaxX, VectorField, 'vector_field_relative')</l>
<l>reconstruct_height_field_from_gradient (VectorField, HDR, 'poisson', ['optimize_speed'], ['patient'])</l>
<l>return ()</l>
</body>
<docu id="create_hdr_image">
<parameters>
<parameter id="HDR"/>
<parameter id="Image1"/>
<parameter id="Image2"/>
</parameters>
</docu>
</procedure>
<procedure name="Two_Eye_Camera">
<interface>
<oo>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="Image_2D" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CamSetupModel" base_type="ctrl" dimension="0"/>
<par name="StereoModelID" base_type="ctrl" dimension="0"/>
<par name="Camera_L" base_type="ctrl" dimension="0"/>
<par name="Camera_R" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Surface3DDefault" base_type="ctrl" dimension="0"/>
<par name="Info" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c>*获得相机参数</c>
<l>get_camera_setup_param (CamSetupModel, 0, 'params', CamParamLeft)</l>
<l>get_camera_setup_param (CamSetupModel, 1, 'params', CamParamRight)</l>
<c></c>
<c>*副相机位置</c>
<l>* get_calib_data (CamSetupModel, 'camera', 1, 'pose', cLPcR)</l>
<c></c>
<l>get_camera_setup_param (CamSetupModel, 0, 'pose', CamSetupModel_Pos)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>count_seconds (Start)</l>
<l>Image_HDR:=0</l>
<c></c>
<l>if (Image_HDR)</l>
<c>    * Image Acquisition 01: Do something</c>
<l>    ExposureTime_Dark:=1000</l>
<l>    ExposureTime_Bright:=8000</l>
<l>    set_framegrabber_param (Camera_L, 'ExposureTime', ExposureTime_Dark)</l>
<l>    set_framegrabber_param (Camera_R, 'ExposureTime', ExposureTime_Dark)</l>
<l>    par_start &lt;Thread_L&gt; :  grab_image (ImageDark_L, Camera_L)</l>
<l>    par_start&lt;Thread_R&gt; : grab_image (ImageDark_R, Camera_R)</l>
<l>    par_join([Thread_L,Thread_R])</l>
<l>    set_framegrabber_param (Camera_L, 'ExposureTime', ExposureTime_Bright)</l>
<l>    set_framegrabber_param (Camera_R, 'ExposureTime', ExposureTime_Bright)</l>
<l>    par_start &lt;Thread_L&gt; :  grab_image (ImageBright_L, Camera_L)</l>
<l>    par_start&lt;Thread_R&gt; : grab_image (ImageBright_R, Camera_R)</l>
<l>    par_join([Thread_L,Thread_R])</l>
<l>    par_start &lt;Thread_L&gt; : create_hdr_image (ImageDark_L, ImageBright_L, HDRImage_L)</l>
<l>    par_start &lt;Thread_R&gt; : create_hdr_image (ImageDark_R, ImageBright_R, HDRImage_R)</l>
<l>    par_join([Thread_L,Thread_R])</l>
<l>    min_max_gray (HDRImage_L, HDRImage_L, 0, Min, Max, Range)</l>
<l>    scale_image_range (HDRImage_L, ImageScaled, [Min,0], [Max,255])</l>
<l>    convert_image_type (ImageScaled, ImageBack, 'byte')</l>
<c>    </c>
<l>    min_max_gray (HDRImage_R, HDRImage_R, 0, Min, Max, Range)</l>
<l>    scale_image_range (HDRImage_R, ImageScaled, [Min,0], [Max,255])</l>
<l>    convert_image_type (ImageScaled, ImageFront, 'byte')</l>
<l>else</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'BlackLevel', 200)</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'ExposureTime', 8000.0)</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'Gain', 19)</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'Gamma', 0.75)</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'StrobeEnable', 0)</l>
<c>    </c>
<l>    par_start &lt;Thread_L&gt; :  grab_image (ImageFront, Camera_L)</l>
<l>*     par_start &lt;Thread_L&gt; : set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>*     par_start &lt;Thread_L&gt; : set_framegrabber_param (Camera_L, 'StrobeEnable', 1)</l>
<c>    </c>
<l>    par_start&lt;Thread_R&gt; :  set_framegrabber_param (Camera_R, 'LineSelector', 'Line1')</l>
<l>    par_start&lt;Thread_R&gt; :  set_framegrabber_param (Camera_R, 'BlackLevel', 200)</l>
<l>    par_start&lt;Thread_R&gt; :  set_framegrabber_param (Camera_R, 'ExposureTime', 5000.0)</l>
<l>     par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_R, 'Gain', 19)</l>
<l>    par_start&lt;Thread_R&gt; :  set_framegrabber_param (Camera_R, 'Gamma', 0.75)</l>
<c>    </c>
<c>    </c>
<l>    par_start&lt;Thread_R&gt; :  set_framegrabber_param (Camera_R, 'StrobeEnable', 1)</l>
<c>    </c>
<c>    </c>
<c>    </c>
<l>*     par_start&lt;Thread_R&gt; : grab_image_start (Camera_R, -1)</l>
<l>    par_start&lt;Thread_R&gt; : grab_image (ImageBack, Camera_R)</l>
<c>    </c>
<c>    </c>
<l>    par_join([Thread_R,Thread_L])</l>
<c>    </c>
<c>    </c>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* median_image (ImageFront, ImageFront, 'square', 3, 'mirrored')</l>
<l>* median_image (ImageBack, ImageBack, 'square', 3, 'mirrored')</l>
<l>* read_image (ImageBack,  ImagesBackFiles[21])</l>
<l>* read_image (ImageFront,  ImagesFrontFiles[21])</l>
<l>emphasize (ImageFront, Front, 100, 100, 5)</l>
<l>emphasize (ImageBack, Back, 100, 100,5)</l>
<l>concat_obj (Front, Back, Images)</l>
<c></c>
<l>* wait_seconds(0.1)</l>
<c>* </c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* par_join([Surface,GetImage])</l>
<c></c>
<l>wait_seconds(0.0)</l>
<c></c>
<c>* Perform the stereo reconstruction.</c>
<c>* 执行立体重建。</c>
<l>reconstruct_surface_stereo (Images, StereoModelID, ObjectModel3DScene)</l>
<c></c>
<c></c>
<l>   get_stereo_model_object (ToImage, StereoModelID, [0, 1], 'to_image_rect')</l>
<l>    get_stereo_model_object (FromImage, StereoModelID, [0, 1], 'from_image_rect')</l>
<c>   </c>
<l>   get_stereo_model_object (DisparityImage, StereoModelID, [0, 1], 'disparity_image')</l>
<l>   get_stereo_model_object (scoreImage, StereoModelID, [0, 1], 'score_image')</l>
<c></c>
<c></c>
<c></c>
<l>* write_object_model_3d (ObjectModel3DScene, 'ply', 'C:/Users/zhiwei2.he/Source/repos/We-sson/HanGao/Halcon_SDK/Halcon样图测试/立体视觉/测试点云.dxf', [], [])</l>
<c></c>
<l>* get_stereo_model_object (FromImage, StereoModelID, [0, 1], 'from_image_rect')</l>
<l>* get_stereo_model_object (ToImage, StereoModelID, [0, 1], 'to_image_rect')</l>
<l>* get_stereo_model_object (DisparityImage, StereoModelID, [0, 1], 'disparity_image')</l>
<l>* get_stereo_model_object (DisparityImage, StereoModelID, [0, 1], 'score_image')</l>
<c></c>
<c></c>
<c>*采集主相机正常曝光图像</c>
<l>* set_framegrabber_param (Camera_L, 'StrobeEnable', 0)</l>
<l>* wait_seconds(1)</l>
<l>* set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>* set_framegrabber_param (Camera_L, 'StrobeEnable', 1)</l>
<l>* set_framegrabber_param (Camera_L, 'BlackLevel', 200)</l>
<l>* set_framegrabber_param (Camera_L, 'ExposureTime', 10000.0)</l>
<l>* set_framegrabber_param (Camera_L, 'Gain', 19)</l>
<l>* set_framegrabber_param (Camera_L, 'Gamma', 0.7)</l>
<c></c>
<l>* grab_image (Image_2D, Camera_L)</l>
<l>* grab_image_async (Image_2D, Camera_L, -1)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* </c>
<c>* Visualize the intermediate results.</c>
<c></c>
<l>* get_image_size (FromImage, WidthFrom, HeightFrom)</l>
<l>* dev_set_window (WindowHandle1)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (FromImage)</l>
<c></c>
<l>* get_image_size (ToImage, WidthTo, HeightTo)</l>
<c></c>
<l>* dev_set_window (WindowHandle2)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (ToImage)</l>
<c></c>
<l>* get_image_size (DisparityImage, Width, Height)</l>
<c></c>
<l>* dev_set_window (WindowHandle3)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (DisparityImage)</l>
<c></c>
<c></c>
<c></c>
<c>*获得点云总数</c>
<l>* get_object_model_3d_params (ObjectModel3DScene, 'num_points', NumPoints)</l>
<c></c>
<c>*点云数据距离进行排序(可选)</c>
<l>* NumNeighbors := 200</l>
<l>* get_object_model_3d_params (ObjectModel3DScene, 'neighbor_distance '+NumNeighbors, DistanceDistribution)</l>
<c></c>
<c>*选择集中距离占比</c>
<l>* InlierRate := 20</l>
<l>* Distance := sort(DistanceDistribution)[|DistanceDistribution| * InlierRate / 100]</l>
<l>* select_points_object_model_3d (ObjectModel3DScene, 'num_neighbors_fast ' + Distance, 12, 'max', OM3DSampledMapping)</l>
<c></c>
<c></c>
<c>*取最小值删除无效数据0(可选)</c>
<l>* select_points_object_model_3d (OM3DSampledMapping, 'num_neighbors_fast 1e-6', 0, 1, OM3DSampledMapping)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*根据点云距离集合分割出</c>
<l>connection_object_model_3d (ObjectModel3DScene, 'distance_3d', 0.002, ObjectModel3DConnected)</l>
<l>select_object_model_3d (ObjectModel3DConnected, 'num_points', 'and', 500, 'max', ObjectModel3DDefect)</l>
<c></c>
<l>union_object_model_3d (ObjectModel3DDefect, 'points_surface', OM3DSampledMapping)</l>
<c></c>
<c></c>
<l>* triangulate_object_model_3d (OM3DSampledMapping, 'xyz_mapping', [], [], TriangulatedDefault, Information0)</l>
<l>* triangulate_object_model_3d (OM3DSampledMapping, 'implicit', ['information','implicit_octree_depth','implicit_solver_depth','implicit_min_num_samples'], ['verbose',12,6,1], Surface3DDefault, Info)</l>
<c></c>
<c></c>
<c></c>
<c>*重采样</c>
<l>* MinNumPoints := 10</l>
<l>* SampleDistance := 0.0001</l>
<l>* sample_object_model_3d (OM3DSampledMapping, 'accurate', SampleDistance, [], [], OM3DSampledMapping)</l>
<c>* </c>
<c></c>
<c></c>
<c>*xyz_mapping 用2D平滑方式修正法线</c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'xyz_mapping', ['xyz_mapping_filter'], ['median'], OM3DSampledMapping)</l>
<c></c>
<c></c>
<c>*计算法线统一方向</c>
<l>surface_normals_object_model_3d (OM3DSampledMapping, 'xyz_mapping', [], [], OM3DSampledMapping)</l>
<c></c>
<c></c>
<c></c>
<c>*mls 平滑方法</c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', [], [], ObjectModel3Dsmooth)</l>
<c></c>
<c></c>
<l>smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_kNN', 200, ObjectModel3Dsmooth)</l>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_order', 1, ObjectModel3Dsmooth)</l>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_abs_sigma', 0.1, ObjectModel3Dsmooth)</l>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_relative_sigma', 2, ObjectModel3Dsmooth) </l>
<c></c>
<c></c>
<c></c>
<l>* object_model_3d_to_xyz (X, Y, Z, ObjectModel3Dsmooth, 'from_xyz_map', [], [])</l>
<c></c>
<c>*表面三角化</c>
<l>* triangulate_object_model_3d (OM3DSampledSample, 'greedy','greedy_hole_filling', 0.005, TriangulatedObjectModel3D, Information)</l>
<c></c>
<c>*获得深度区域</c>
<l>* get_domain (Z, Z_Reg)</l>
<c>*闭运算消除毛刺</c>
<l>* closing_circle (Z_Reg, RegionClosing, 10)</l>
<l>* closing_rectangle1 (Z_Reg, RegionClosing, 20, 20)</l>
<c></c>
<c>*填充空洞</c>
<l>* fill_up (RegionClosing, Z_Conves)</l>
<c></c>
<c>*区域凸包</c>
<l>* shape_trans (Z, Z_Conves, 'convex')</l>
<c></c>
<c>*区域相差</c>
<l>* difference (Z_Conves, Z, Z_Region)</l>
<c></c>
<l>* full_domain (X, X_Full)</l>
<l>* full_domain (Y, Y_Full)</l>
<l>* full_domain (Z, Z_Full)</l>
<c></c>
<l>* change_domain (X_Full, Z_Conves, X_Domain)</l>
<l>* change_domain (Y_Full, Z_Conves, Y_Domain)</l>
<l>* change_domain (Z_Full, Z_Conves, Z_Domain)</l>
<c></c>
<c></c>
<c>*线性修复</c>
<l>* harmonic_interpolation (X_Domain, Z_Region, X_interpolation, 0.00001)</l>
<l>* harmonic_interpolation (Y_Domain, Z_Region, Y_interpolation, 0.00001)</l>
<l>* harmonic_interpolation (Z_Domain, Z_Region, Z_interpolation, 0.00001)</l>
<c></c>
<l>* inpainting_ct (X_interpolation, Z_Region, X_Harmonic, 10, 25, 10, 0.1, 1)</l>
<l>* inpainting_ct (Y_interpolation, Z_Region, Y_Harmonic,20, 25, 1, 1, 1)</l>
<l>* inpainting_ct (Z_interpolation, Z_Region, Z_Harmonic, 20, 25, 1, 1, 1)</l>
<c></c>
<c></c>
<l>* inpainting_ced (X_interpolation, Z_Region, X_Harmonic, 3, 1, 5, 300)</l>
<l>* inpainting_ced (Y_interpolation, Z_Region, Y_Harmonic, 3, 1, 5, 300)</l>
<l>* inpainting_ced (Z_interpolation, Z_Region, Z_Harmonic, 3, 1, 5, 300)</l>
<c></c>
<l>* inpainting_mcf (X_interpolation, Z_Region, X_Harmonic, 10, 0.1, 100)</l>
<l>* inpainting_mcf (Y_interpolation, Z_Region, Y_Harmonic,10, 0.5, 100)</l>
<l>* inpainting_mcf (Z_interpolation, Z_Region, Z_Harmonic, 10, 0.5, 100)</l>
<c></c>
<l>* inpainting_texture (X_interpolation, Z_Region, X_Harmonic,11, 40, 0, 'none', 0)</l>
<l>* inpainting_texture (Y_interpolation, Z_Region, Y_Harmonic, 9, 30, 1, 'none', 0.1)</l>
<l>* inpainting_texture (Z_interpolation, Z_Region, Z_Harmonic, 9, 30, 1, 'none', 0.1)</l>
<c></c>
<l>* inpainting_aniso (X_Domain, Z_Region, X_Harmonic,'shock', 5, 5, 60, 1)</l>
<l>* inpainting_aniso (Y_Domain, Z_Region, Y_Harmonic,'shock', 5, 5, 60, 1)</l>
<l>* inpainting_aniso (Z_Domain, Z_Region, Z_Harmonic,'shock', 5, 5, 60, 1)</l>
<c></c>
<c></c>
<l>* xyz_to_object_model_3d (X_Harmonic, Y_Harmonic, Z_Harmonic, ObjectModel3D)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'xyz_mapping_compute_normals', ['xyz_mapping_mask_width','xyz_mapping_mask_height'], [5,5], ObjectModel3Dsmooth)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* 'greedy_kNN' --&gt; 40</c>
<c>* 'greedy_radius_type' --&gt; 'auto'</c>
<c>* 'greedy_radius_value' --&gt; 1.0</c>
<c>* 'greedy_neigh_orient_tol' --&gt; 30</c>
<c>* 'greedy_neigh_orient_consistent' --&gt; 'false'</c>
<c>* 'greedy_neigh_vertical_tol' --&gt; 0.1</c>
<c>* 'greedy_neigh_latitude_tol' --&gt; 30</c>
<c>* 'greedy_hole_filling' --&gt; 40</c>
<c>* 'greedy_fix_flips' --&gt; 'true'</c>
<c>* 'greedy_mesh_erosion' --&gt; 0</c>
<c>* 'greedy_mesh_dilation' --&gt; 0</c>
<c>* 'greedy_remove_small_surfaces' --&gt; 'false'</c>
<c>* 'greedy_prefetch_neighbors' --&gt; 'true'</c>
<c>* 'greedy_timeout' --&gt; 'false'</c>
<c>* 'greedy_suppress_timeout_error' --&gt; 'false'</c>
<c>* 'information' --&gt; 'num_triangles'</c>
<c></c>
<c></c>
<l>ParameterNames := ['information','greedy_kNN','greedy_radius_type','greedy_radius_value','greedy_neigh_orient_tol','greedy_neigh_orient_consistent','greedy_neigh_latitude_tol','greedy_neigh_vertical_tol','greedy_hole_filling','greedy_fix_flips','greedy_prefetch_neighbors','greedy_mesh_erosion','greedy_mesh_dilation']</l>
<l>ParameterValues := ['verbose',55,'fixed',0.005,100,'false',100,0.5,100000,'true','true',1,5]</l>
<c></c>
<c>*三角化预生产，减少计算时间</c>
<l>prepare_object_model_3d (ObjectModel3Dsmooth, 'segmentation', 'true', ['max_area_holes'], [100])</l>
<c>*测量三角化计算</c>
<l>triangulate_object_model_3d (ObjectModel3Dsmooth, 'greedy', ParameterNames , ParameterValues, Surface3DDefault, Info)</l>
<c></c>
<l>* triangulate_object_model_3d (ObjectModel3Dsmooth, 'polygon_triangulation', [], [], TriangulatedObjectModel3D, Information)</l>
<c></c>
<c></c>
<l>triangulate_object_model_3d (ObjectModel3Dsmooth, 'greedy', ParameterNames , ParameterValues, Surface3DDefault1, Info)</l>
<l>union_object_model_3d (Surface3DDefault, 'points_surface', Surface3DDefault1)</l>
<c></c>
<c></c>
<c>*反转点云位置</c>
<l>pose_invert (CamSetupModel_Pos, Pos_CamInObj)</l>
<l>* sample_object_model_3d (Surface3DDefault, 'accurate_use_normals', 0.0002, [], [], OM3DSampledMapping)</l>
<c></c>
<l>* triangulate_object_model_3d (ObjectModel3Dsmooth, 'greedy', [], [], TriangulatedObjectModel3D, Information)</l>
<c></c>
<c></c>
<c></c>
<l>object_model_3d_to_xyz (X, Y, Z, Surface3DDefault, 'cartesian_faces', CamParamLeft, Pos_CamInObj)</l>
<c></c>
<l>compose3 (X, Y, Z, XYZImage)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* get_domain (Z, Domain)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* object_model_3d_to_xyz (X2, Y2, Z2, ObjectModel3Dsmooth, 'from_xyz_map', [], [])</l>
<c></c>
<c>*缩放深度图到图像大小</c>
<l>* get_image_size (ImageFront, Width1, Height1)</l>
<l>* zoom_image_size (Z1, ImageZoom, Width1/2, Height1/2, 'constant')</l>
<l>* zoom_image_size (ImageFront, ImageFrontZoom, Width1/2, Height1/2, 'constant')</l>
<l>* zoom_image_size (ImageFront, ImageFrontZoom, Width1, Height1, 'nearest_neighbor')</l>
<l>count_seconds (End)</l>
<l>TimeDefault := End - Start</l>
<c></c>
<l>* dev_display (Image_2D)</l>
<l>* dev_display (Z)</l>
<c></c>
<l>Info:= [ '耗时：'+TimeDefault+'秒']</l>
<c></c>
<l>* wait_seconds (1)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (ImageZoom)</l>
<l>* sample_object_model_3d (ObjectModel3DScene, 'furthest_point_compute_normals',1, [], [], OM3DSampledMapping)</l>
<c></c>
<l>* sample_object_model_3d (ObjectModel3DScene, 'accurate',0.0001, ['min_num_points'], [210], OM3DSampledMapping)</l>
<c></c>
<c></c>
<c></c>
<l>* connection_object_model_3d (ObjectModel3DScene, 'distance_3d',0.006, ObjectModel3DConnected)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* stop ()</l>
<c>* </c>
<c>* Visualize the stereo reconstruction.</c>
<l>* visualize_object_model_3d (WindowHandle3, ObjectModel3DScene, [], [], [],[], '3D reconstruction with projected gray values', [], [], VisPose)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="Two_Eye_Camera">
<parameters>
<parameter id="CamSetupModel">
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Camera_L">
<mixed_type>false</mixed_type>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Camera_R">
<mixed_type>false</mixed_type>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image_2D">
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Info">
<sem_type>string</sem_type>
</parameter>
<parameter id="StereoModelID">
<mixed_type>false</mixed_type>
<sem_type>stereo_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Surface3DDefault">
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="X">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Y">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Z">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="parameters_image_to_world_plane_entire">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="WidthMappedImage" base_type="ctrl" dimension="0"/>
<par name="HeightMappedImage" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ScaleForEntireImage" base_type="ctrl" dimension="0"/>
<par name="PoseForEntireImage" base_type="ctrl" dimension="0"/>
<par name="WidthRect" base_type="ctrl" dimension="0"/>
<par name="HeightRect" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Transform the image border into the WCS (scale = 1)</c>
<l>full_domain (Image, ImageFull)</l>
<l>get_domain (ImageFull, Domain)</l>
<l>gen_contour_region_xld (Domain, ImageBorder, 'border')</l>
<l>contour_to_world_plane_xld (ImageBorder, ImageBorderWCS, CamParam, Pose, 1)</l>
<l>smallest_rectangle1_xld (ImageBorderWCS, MinY, MinX, MaxY, MaxX)</l>
<c></c>
<c>* Determine the scale of the mapping</c>
<l>ExtentX := MaxX - MinX</l>
<l>ExtentY := MaxY - MinY</l>
<l>ScaleX := (ExtentX / WidthMappedImage)</l>
<l>ScaleY := (ExtentY / HeightMappedImage)</l>
<l>ScaleForEntireImage := min([ScaleX,ScaleY])</l>
<l>*ScaleForEntireImage:=(ScaleX+ScaleY)/2</l>
<l>*ScaleForEntireImage:=0.0000364518</l>
<l>WidthRect := int((MaxX- MinX) / ScaleForEntireImage) </l>
<l>HeightRect := int((MaxY- MinY) / ScaleForEntireImage) </l>
<c></c>
<c>* Shift the pose by the minimum X and Y coordinates</c>
<l>set_origin_pose (Pose, MinX, MinY, 0, PoseForEntireImage)</l>
<l>return ()</l>
</body>
<docu id="parameters_image_to_world_plane_entire">
<short lang="en_US">Determine scale and pose such that the whole image fits into the rectified image.</short>
<parameters>
<parameter id="CamParam"/>
<parameter id="HeightMappedImage"/>
<parameter id="HeightRect"/>
<parameter id="Image"/>
<parameter id="Pose"/>
<parameter id="PoseForEntireImage"/>
<parameter id="ScaleForEntireImage"/>
<parameter id="WidthMappedImage"/>
<parameter id="WidthRect"/>
</parameters>
</docu>
</procedure>
<procedure name="Register_3DModel">
<interface>
<oo>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="Image_2D" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CamSetupModel" base_type="ctrl" dimension="0"/>
<par name="StereoModelID" base_type="ctrl" dimension="0"/>
<par name="Camera_L" base_type="ctrl" dimension="0"/>
<par name="Camera_R" base_type="ctrl" dimension="0"/>
<par name="Window" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Surface3DDefault" base_type="ctrl" dimension="0"/>
<par name="Info" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c></c>
<l>Button:=0</l>
<l>ImgNo:=0</l>
<l>gen_empty_object_model_3d (All_ObjectModel3D)</l>
<l>*gen_empty_object_model_3d (All_ObjectModel3D_Offset)</l>
<l>HomMat3D_Offsets := []</l>
<l>HomMat3D_Global:=[]</l>
<l>hom_mat3d_identity (HomMat3DStart)</l>
<l>HomMat3DCompose := HomMat3DStart</l>
<l>while (Button != 4)</l>
<c>    </c>
<c></c>
<c></c>
<c>*获得相机参数</c>
<l>get_camera_setup_param (CamSetupModel, 0, 'params', CamParamLeft)</l>
<l>get_camera_setup_param (CamSetupModel, 1, 'params', CamParamRight)</l>
<c></c>
<c>*副相机位置</c>
<l>* get_calib_data (CamSetupModel, 'camera', 1, 'pose', cLPcR)</l>
<c></c>
<l>get_camera_setup_param (CamSetupModel, 0, 'pose', CamSetupModel_Pos)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>count_seconds (Start)</l>
<l>Image_HDR:=0</l>
<c></c>
<l>if (Image_HDR)</l>
<c>    * Image Acquisition 01: Do something</c>
<l>    ExposureTime_Dark:=1000</l>
<l>    ExposureTime_Bright:=8000</l>
<l>    set_framegrabber_param (Camera_L, 'ExposureTime', ExposureTime_Dark)</l>
<l>    set_framegrabber_param (Camera_R, 'ExposureTime', ExposureTime_Dark)</l>
<l>    par_start &lt;Thread_L&gt; :  grab_image (ImageDark_L, Camera_L)</l>
<l>    par_start&lt;Thread_R&gt; : grab_image (ImageDark_R, Camera_R)</l>
<l>    par_join([Thread_L,Thread_R])</l>
<l>    set_framegrabber_param (Camera_L, 'ExposureTime', ExposureTime_Bright)</l>
<l>    set_framegrabber_param (Camera_R, 'ExposureTime', ExposureTime_Bright)</l>
<l>    par_start &lt;Thread_L&gt; :  grab_image (ImageBright_L, Camera_L)</l>
<l>    par_start&lt;Thread_R&gt; : grab_image (ImageBright_R, Camera_R)</l>
<l>    par_join([Thread_L,Thread_R])</l>
<l>    par_start &lt;Thread_L&gt; : create_hdr_image (ImageDark_L, ImageBright_L, HDRImage_L)</l>
<l>    par_start &lt;Thread_R&gt; : create_hdr_image (ImageDark_R, ImageBright_R, HDRImage_R)</l>
<l>    par_join([Thread_L,Thread_R])</l>
<l>    min_max_gray (HDRImage_L, HDRImage_L, 0, Min, Max, Range)</l>
<l>    scale_image_range (HDRImage_L, ImageScaled, [Min,0], [Max,255])</l>
<l>    convert_image_type (ImageScaled, ImageBack, 'byte')</l>
<c>    </c>
<l>    min_max_gray (HDRImage_R, HDRImage_R, 0, Min, Max, Range)</l>
<l>    scale_image_range (HDRImage_R, ImageScaled, [Min,0], [Max,255])</l>
<l>    convert_image_type (ImageScaled, ImageFront, 'byte')</l>
<l>else</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'BlackLevel', 200)</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'ExposureTime', 5000.0)</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'Gain', 19)</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'Gamma', 0.7)</l>
<l>    par_start &lt;Thread_L&gt; :  set_framegrabber_param (Camera_L, 'StrobeEnable', 0)</l>
<c>    </c>
<l>    par_start &lt;Thread_L&gt; :  grab_image (ImageFront, Camera_L)</l>
<l>*     par_start &lt;Thread_L&gt; : set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>*     par_start &lt;Thread_L&gt; : set_framegrabber_param (Camera_L, 'StrobeEnable', 1)</l>
<c>    </c>
<l>    par_start&lt;Thread_R&gt; :  set_framegrabber_param (Camera_R, 'LineSelector', 'Line1')</l>
<l>    par_start&lt;Thread_R&gt; :  set_framegrabber_param (Camera_R, 'BlackLevel', 200)</l>
<l>    par_start&lt;Thread_R&gt; :  set_framegrabber_param (Camera_R, 'ExposureTime', 5000.0)</l>
<c>    </c>
<l>    par_start&lt;Thread_R&gt; :  set_framegrabber_param (Camera_R, 'Gamma', 0.7)</l>
<c>    </c>
<c>    </c>
<l>    par_start&lt;Thread_R&gt; :  set_framegrabber_param (Camera_R, 'StrobeEnable', 1)</l>
<c>    </c>
<c>    </c>
<c>    </c>
<l>*     par_start&lt;Thread_R&gt; : grab_image_start (Camera_R, -1)</l>
<l>    par_start&lt;Thread_R&gt; : grab_image (ImageBack, Camera_R)</l>
<c>    </c>
<c>    </c>
<l>    par_join([Thread_R,Thread_L])</l>
<c>    </c>
<c>    </c>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* median_image (ImageFront, ImageFront, 'square', 3, 'mirrored')</l>
<l>* median_image (ImageBack, ImageBack, 'square', 3, 'mirrored')</l>
<l>* read_image (ImageBack,  ImagesBackFiles[21])</l>
<l>* read_image (ImageFront,  ImagesFrontFiles[21])</l>
<l>emphasize (ImageFront, Front, 100, 100, 5)</l>
<l>emphasize (ImageBack, Back, 100, 100,5)</l>
<l>concat_obj (Front, Back, Images)</l>
<c></c>
<l>* wait_seconds(0.1)</l>
<c>* </c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* Perform the stereo reconstruction.</c>
<c>* 执行立体重建。</c>
<l>reconstruct_surface_stereo (Images, StereoModelID, ObjectModel3DScene)</l>
<c></c>
<l>* write_object_model_3d (ObjectModel3DScene, 'ply', 'C:/Users/zhiwei2.he/Source/repos/We-sson/HanGao/Halcon_SDK/Halcon样图测试/立体视觉/测试点云.dxf', [], [])</l>
<c></c>
<l>* get_stereo_model_object (FromImage, StereoModelID, [0, 1], 'from_image_rect')</l>
<l>* get_stereo_model_object (ToImage, StereoModelID, [0, 1], 'to_image_rect')</l>
<l>* get_stereo_model_object (DisparityImage, StereoModelID, [0, 1], 'disparity_image')</l>
<l>* get_stereo_model_object (DisparityImage, StereoModelID, [0, 1], 'score_image')</l>
<c></c>
<c></c>
<c>* </c>
<c>* Visualize the intermediate results.</c>
<c></c>
<l>* get_image_size (FromImage, WidthFrom, HeightFrom)</l>
<l>* dev_set_window (WindowHandle1)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (FromImage)</l>
<c></c>
<l>* get_image_size (ToImage, WidthTo, HeightTo)</l>
<c></c>
<l>* dev_set_window (WindowHandle2)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (ToImage)</l>
<c></c>
<l>* get_image_size (DisparityImage, Width, Height)</l>
<c></c>
<l>* dev_set_window (WindowHandle3)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (DisparityImage)</l>
<c></c>
<c></c>
<c></c>
<c>*获得点云总数</c>
<l>* get_object_model_3d_params (ObjectModel3DScene, 'num_points', NumPoints)</l>
<c></c>
<c>*点云数据距离进行排序(可选)</c>
<l>* NumNeighbors := 200</l>
<l>* get_object_model_3d_params (ObjectModel3DScene, 'neighbor_distance '+NumNeighbors, DistanceDistribution)</l>
<c></c>
<c>*选择集中距离占比</c>
<l>* InlierRate := 20</l>
<l>* Distance := sort(DistanceDistribution)[|DistanceDistribution| * InlierRate / 100]</l>
<l>* select_points_object_model_3d (ObjectModel3DScene, 'num_neighbors_fast ' + Distance, 12, 'max', OM3DSampledMapping)</l>
<c></c>
<c></c>
<c>*取最小值删除无效数据0(可选)</c>
<l>* select_points_object_model_3d (OM3DSampledMapping, 'num_neighbors_fast 1e-6', 0, 1, OM3DSampledMapping)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*根据点云距离集合分割出</c>
<l>connection_object_model_3d (ObjectModel3DScene, 'distance_3d', 0.001, ObjectModel3DConnected)</l>
<l>select_object_model_3d (ObjectModel3DConnected, 'num_points', 'and', 500, 'max', ObjectModel3DDefect)</l>
<c></c>
<l>union_object_model_3d (ObjectModel3DDefect, 'points_surface', OM3DSampledMapping)</l>
<c></c>
<c></c>
<l>* triangulate_object_model_3d (OM3DSampledMapping, 'xyz_mapping', [], [], TriangulatedDefault, Information0)</l>
<l>* triangulate_object_model_3d (OM3DSampledMapping, 'implicit', ['information','implicit_octree_depth','implicit_solver_depth','implicit_min_num_samples'], ['verbose',12,6,1], Surface3DDefault, Info)</l>
<c></c>
<c></c>
<c></c>
<c>*重采样</c>
<l>* MinNumPoints := 10</l>
<l>* SampleDistance := 0.0001</l>
<l>* sample_object_model_3d (OM3DSampledMapping, 'accurate', SampleDistance, [], [], OM3DSampledMapping)</l>
<c>* </c>
<c></c>
<c></c>
<c>*xyz_mapping 用2D平滑方式修正法线</c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'xyz_mapping', ['xyz_mapping_filter'], ['median'], OM3DSampledMapping)</l>
<c></c>
<c></c>
<c>*计算法线统一方向</c>
<l>surface_normals_object_model_3d (OM3DSampledMapping, 'xyz_mapping', [], [], OM3DSampledMapping)</l>
<c></c>
<c></c>
<c></c>
<c>*mls 平滑方法</c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', [], [], ObjectModel3Dsmooth)</l>
<c></c>
<c></c>
<l>smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_kNN', 150, ObjectModel3Dsmooth)</l>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_order', 1, ObjectModel3Dsmooth)</l>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_abs_sigma', 0.1, ObjectModel3Dsmooth)</l>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_relative_sigma', 2, ObjectModel3Dsmooth) </l>
<c></c>
<c></c>
<c></c>
<l>* object_model_3d_to_xyz (X, Y, Z, ObjectModel3Dsmooth, 'from_xyz_map', [], [])</l>
<c></c>
<c>*表面三角化</c>
<l>* triangulate_object_model_3d (OM3DSampledSample, 'greedy','greedy_hole_filling', 0.005, TriangulatedObjectModel3D, Information)</l>
<c></c>
<c>*获得深度区域</c>
<l>* get_domain (Z, Z_Reg)</l>
<c>*闭运算消除毛刺</c>
<l>* closing_circle (Z_Reg, RegionClosing, 10)</l>
<l>* closing_rectangle1 (Z_Reg, RegionClosing, 20, 20)</l>
<c></c>
<c>*填充空洞</c>
<l>* fill_up (RegionClosing, Z_Conves)</l>
<c></c>
<c>*区域凸包</c>
<l>* shape_trans (Z, Z_Conves, 'convex')</l>
<c></c>
<c>*区域相差</c>
<l>* difference (Z_Conves, Z, Z_Region)</l>
<c></c>
<l>* full_domain (X, X_Full)</l>
<l>* full_domain (Y, Y_Full)</l>
<l>* full_domain (Z, Z_Full)</l>
<c></c>
<l>* change_domain (X_Full, Z_Conves, X_Domain)</l>
<l>* change_domain (Y_Full, Z_Conves, Y_Domain)</l>
<l>* change_domain (Z_Full, Z_Conves, Z_Domain)</l>
<c></c>
<c></c>
<c>*线性修复</c>
<l>* harmonic_interpolation (X_Domain, Z_Region, X_interpolation, 0.00001)</l>
<l>* harmonic_interpolation (Y_Domain, Z_Region, Y_interpolation, 0.00001)</l>
<l>* harmonic_interpolation (Z_Domain, Z_Region, Z_interpolation, 0.00001)</l>
<c></c>
<l>* inpainting_ct (X_interpolation, Z_Region, X_Harmonic, 10, 25, 10, 0.1, 1)</l>
<l>* inpainting_ct (Y_interpolation, Z_Region, Y_Harmonic,20, 25, 1, 1, 1)</l>
<l>* inpainting_ct (Z_interpolation, Z_Region, Z_Harmonic, 20, 25, 1, 1, 1)</l>
<c></c>
<c></c>
<l>* inpainting_ced (X_interpolation, Z_Region, X_Harmonic, 3, 1, 5, 300)</l>
<l>* inpainting_ced (Y_interpolation, Z_Region, Y_Harmonic, 3, 1, 5, 300)</l>
<l>* inpainting_ced (Z_interpolation, Z_Region, Z_Harmonic, 3, 1, 5, 300)</l>
<c></c>
<l>* inpainting_mcf (X_interpolation, Z_Region, X_Harmonic, 10, 0.1, 100)</l>
<l>* inpainting_mcf (Y_interpolation, Z_Region, Y_Harmonic,10, 0.5, 100)</l>
<l>* inpainting_mcf (Z_interpolation, Z_Region, Z_Harmonic, 10, 0.5, 100)</l>
<c></c>
<l>* inpainting_texture (X_interpolation, Z_Region, X_Harmonic,11, 40, 0, 'none', 0)</l>
<l>* inpainting_texture (Y_interpolation, Z_Region, Y_Harmonic, 9, 30, 1, 'none', 0.1)</l>
<l>* inpainting_texture (Z_interpolation, Z_Region, Z_Harmonic, 9, 30, 1, 'none', 0.1)</l>
<c></c>
<l>* inpainting_aniso (X_Domain, Z_Region, X_Harmonic,'shock', 5, 5, 60, 1)</l>
<l>* inpainting_aniso (Y_Domain, Z_Region, Y_Harmonic,'shock', 5, 5, 60, 1)</l>
<l>* inpainting_aniso (Z_Domain, Z_Region, Z_Harmonic,'shock', 5, 5, 60, 1)</l>
<c></c>
<c></c>
<l>* xyz_to_object_model_3d (X_Harmonic, Y_Harmonic, Z_Harmonic, ObjectModel3D)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'xyz_mapping_compute_normals', ['xyz_mapping_mask_width','xyz_mapping_mask_height'], [5,5], ObjectModel3Dsmooth)</l>
<c></c>
<c>    *选择出最大区域得图像</c>
<l>    connection_object_model_3d (ObjectModel3Dsmooth, 'distance_3d',0.001, ObjectModel3DConnected)</l>
<l>    get_object_model_3d_params (ObjectModel3DConnected, 'num_points', ObjectModel3DConnected_Num)</l>
<l>    tuple_max (ObjectModel3DConnected_Num, Max)</l>
<l>    select_object_model_3d (ObjectModel3DConnected, 'num_points', 'and', Max, 'max', ObjectModel3DDefect)</l>
<c></c>
<c>    </c>
<c>    </c>
<c> </c>
<l>if (ImgNo=0)</l>
<l>    Find_ObjectModel3D:=ObjectModel3DDefect</l>
<l>    All_ObjectModel3D:=ObjectModel3DDefect</l>
<l>    copy_object_model_3d (ObjectModel3DDefect, 'all', All_ObjectModel3D_Offset)</l>
<l>    moments_object_model_3d (ObjectModel3DDefect, 'principal_axes', Moments)</l>
<l>    *pose_to_hom_mat3d (Moments, HomMat3DStart)</l>
<l>     hom_mat3d_identity (HomMat3DStart)</l>
<l>    HomMat3D_Global:=[]</l>
<l>    ImgNo:=ImgNo+1</l>
<c>    </c>
<c>    </c>
<c>*采集主相机正常曝光图像</c>
<l>set_framegrabber_param (Camera_L, 'StrobeEnable', 0)</l>
<l>* wait_seconds(1)</l>
<l>set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>set_framegrabber_param (Camera_L, 'StrobeEnable', 1)</l>
<l>set_framegrabber_param (Camera_L, 'BlackLevel', 200)</l>
<l>set_framegrabber_param (Camera_L, 'ExposureTime', 80000.0)</l>
<l>set_framegrabber_param (Camera_L, 'Gain', 19)</l>
<l>set_framegrabber_param (Camera_L, 'Gamma', 0.7)</l>
<c></c>
<l>* grab_image (Image_2D, Camera_L)</l>
<l>grab_image_async (Image_2D, Camera_L, -1)</l>
<c>    </c>
<c>    </c>
<l>else</l>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    </c>
<c></c>
<c>    *采集模型预配装</c>
<c>    </c>
<l>    register_object_model_3d_pair (ObjectModel3DDefect, Find_ObjectModel3D, 'matching', ['default_parameters'], ['accurate'], Pose, Score)</l>
<l>    View_Model:=[ObjectModel3DDefect,Find_ObjectModel3D]</l>
<c>    * If registration failed, ignore this view</c>
<l>    if (|Pose| == 0 or Score &lt; 0.8)</l>
<l>        stop()</l>
<l>        continue</l>
<l>    endif</l>
<l>    pose_to_hom_mat3d (Pose, HomMat3D)</l>
<c>    *保存原模型</c>
<l>    All_ObjectModel3D := [All_ObjectModel3D,ObjectModel3DDefect]</l>
<l>    HomMat3D_Offsets := [HomMat3D,HomMat3D_Offsets]</l>
<c>    * Create 3D object model for visualization</c>
<l>*     hom_mat3d_invert (HomMat3DStart, HomMat3DStart_Invert)</l>
<l>     hom_mat3d_compose (HomMat3DStart, HomMat3D, HomMat3DCompose)</l>
<l>     hom_mat3d_to_pose (HomMat3DCompose, Pose1)</l>
<l>     HomMat3D_Global:=[HomMat3D_Global,HomMat3DCompose]</l>
<c>     </c>
<c>     </c>
<c>    </c>
<l>    affine_trans_object_model_3d (ObjectModel3DDefect, HomMat3D, ObjectModel3DAffineTrans)</l>
<l>     View_Model_Offset:=[Find_ObjectModel3D,ObjectModel3DAffineTrans]</l>
<c>    </c>
<l>    All_ObjectModel3D_Offset := [ObjectModel3DAffineTrans,All_ObjectModel3D_Offset]</l>
<c>    * Prepare next round</c>
<c>    </c>
<l>    ObjectModel3DDefect:=Find_ObjectModel3D</l>
<c>    </c>
<c>    </c>
<l>    wait_seconds (0.5)</l>
<l>   *get_mbutton (Window, Row, Column, Button)</l>
<l>    if (Button==4)</l>
<l>        break</l>
<l>    endif</l>
<l>    ImgNo:=ImgNo+1</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>endwhile</l>
<c></c>
<c></c>
<l>union_object_model_3d (All_ObjectModel3D_Offset, 'points_surface', ObjectModel3Dsmooth)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>register_object_model_3d_global( All_ObjectModel3D ,HomMat3D_Global, 'previous',[], ['default_parameters'], ['accurate'], HomMat3DRefined, Score)</l>
<c>* Apply results</c>
<l>affine_trans_object_model_3d (All_ObjectModel3D, HomMat3DRefined, GloballyRegisteredOM3s)</l>
<c></c>
<c></c>
<l>* MinNumPoints := 2</l>
<l>* SampleDistance := 0.0002</l>
<l>* sample_object_model_3d (ObjectModel3Dsmooth, 'accurate_use_normals', SampleDistance, 'min_num_points', MinNumPoints, ObjectModel3Dsmooth)</l>
<c>* </c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* par_join([Surface,GetImage])</l>
<c></c>
<l>wait_seconds(0.0)</l>
<c></c>
<c>* 'greedy_kNN' --&gt; 40</c>
<c>* 'greedy_radius_type' --&gt; 'auto'</c>
<c>* 'greedy_radius_value' --&gt; 1.0</c>
<c>* 'greedy_neigh_orient_tol' --&gt; 30</c>
<c>* 'greedy_neigh_orient_consistent' --&gt; 'false'</c>
<c>* 'greedy_neigh_vertical_tol' --&gt; 0.1</c>
<c>* 'greedy_neigh_latitude_tol' --&gt; 30</c>
<c>* 'greedy_hole_filling' --&gt; 40</c>
<c>* 'greedy_fix_flips' --&gt; 'true'</c>
<c>* 'greedy_mesh_erosion' --&gt; 0</c>
<c>* 'greedy_mesh_dilation' --&gt; 0</c>
<c>* 'greedy_remove_small_surfaces' --&gt; 'false'</c>
<c>* 'greedy_prefetch_neighbors' --&gt; 'true'</c>
<c>* 'greedy_timeout' --&gt; 'false'</c>
<c>* 'greedy_suppress_timeout_error' --&gt; 'false'</c>
<c>* 'information' --&gt; 'num_triangles'</c>
<c></c>
<c></c>
<l>ParameterNames := ['information','greedy_kNN','greedy_radius_type','greedy_radius_value','greedy_neigh_orient_tol','greedy_neigh_orient_consistent','greedy_neigh_latitude_tol','greedy_neigh_vertical_tol','greedy_hole_filling','greedy_fix_flips','greedy_prefetch_neighbors','greedy_mesh_erosion','greedy_mesh_dilation']</l>
<l>ParameterValues := ['verbose',25,'fixed',0.003,100,'false',100,0.1,100000,'true','true',30,0]</l>
<c></c>
<c>*三角化预生产，减少计算时间</c>
<l>prepare_object_model_3d (ObjectModel3Dsmooth, 'segmentation', 'true', ['max_area_holes'], [200])</l>
<c>*测量三角化计算</c>
<l>triangulate_object_model_3d (ObjectModel3Dsmooth, 'greedy', ParameterNames , ParameterValues, Surface3DDefault, Info)</l>
<c></c>
<l>* triangulate_object_model_3d (ObjectModel3Dsmooth, 'polygon_triangulation', [], [], TriangulatedObjectModel3D, Information)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*反转点云位置</c>
<l>pose_invert (CamSetupModel_Pos, Pos_CamInObj)</l>
<l>* sample_object_model_3d (Surface3DDefault, 'accurate_use_normals', 0.0002, [], [], OM3DSampledMapping)</l>
<c></c>
<l>* triangulate_object_model_3d (ObjectModel3Dsmooth, 'greedy', [], [], TriangulatedObjectModel3D, Information)</l>
<c></c>
<c></c>
<c></c>
<l>object_model_3d_to_xyz (X, Y, Z, Surface3DDefault, 'cartesian_faces', CamParamLeft, Pos_CamInObj)</l>
<c></c>
<l>compose3 (X, Y, Z, XYZImage)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* get_domain (Z, Domain)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* object_model_3d_to_xyz (X2, Y2, Z2, ObjectModel3Dsmooth, 'from_xyz_map', [], [])</l>
<c></c>
<c>*缩放深度图到图像大小</c>
<l>* get_image_size (ImageFront, Width1, Height1)</l>
<l>* zoom_image_size (Z1, ImageZoom, Width1/2, Height1/2, 'constant')</l>
<l>* zoom_image_size (ImageFront, ImageFrontZoom, Width1/2, Height1/2, 'constant')</l>
<l>* zoom_image_size (ImageFront, ImageFrontZoom, Width1, Height1, 'nearest_neighbor')</l>
<l>count_seconds (End)</l>
<l>TimeDefault := End - Start</l>
<c></c>
<l>* dev_display (Image_2D)</l>
<l>* dev_display (Z)</l>
<c></c>
<l>Info:= [ '耗时：'+TimeDefault+'秒']</l>
<c></c>
<l>* wait_seconds (1)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (ImageZoom)</l>
<l>* sample_object_model_3d (ObjectModel3DScene, 'furthest_point_compute_normals',1, [], [], OM3DSampledMapping)</l>
<c></c>
<l>* sample_object_model_3d (ObjectModel3DScene, 'accurate',0.0001, ['min_num_points'], [210], OM3DSampledMapping)</l>
<c></c>
<c></c>
<c></c>
<l>* connection_object_model_3d (ObjectModel3DScene, 'distance_3d',0.006, ObjectModel3DConnected)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* stop ()</l>
<c>* </c>
<c>* Visualize the stereo reconstruction.</c>
<l>* visualize_object_model_3d (WindowHandle3, ObjectModel3DScene, [], [], [],[], '3D reconstruction with projected gray values', [], [], VisPose)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="Register_3DModel">
<parameters>
<parameter id="CamSetupModel">
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Camera_L">
<mixed_type>false</mixed_type>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Camera_R">
<mixed_type>false</mixed_type>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image_2D">
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Info">
<sem_type>string</sem_type>
</parameter>
<parameter id="StereoModelID">
<mixed_type>false</mixed_type>
<sem_type>stereo_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Surface3DDefault">
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Window">
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="X">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Y">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Z">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="Union_Two_Camera">
<interface>
<oo>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="Image_2D" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CamSetupModel" base_type="ctrl" dimension="0"/>
<par name="StereoModelID" base_type="ctrl" dimension="0"/>
<par name="Camera_L" base_type="ctrl" dimension="0"/>
<par name="Camera_R" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Surface3DDefault" base_type="ctrl" dimension="0"/>
<par name="Info" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c>*获得相机参数</c>
<l>get_camera_setup_param (CamSetupModel, 0, 'params', CamParamLeft)</l>
<l>get_camera_setup_param (CamSetupModel, 1, 'params', CamParamRight)</l>
<c></c>
<c>*副相机位置</c>
<l>* get_calib_data (CamSetupModel, 'camera', 1, 'pose', cLPcR)</l>
<c></c>
<l>get_camera_setup_param (CamSetupModel, 0, 'pose', CamSetupModel_Pos)</l>
<c></c>
<c></c>
<l>grab_image_start (Camera_R, -1)</l>
<l>grab_image_start (Camera_L, -1)</l>
<c></c>
<c></c>
<l>set_framegrabber_param (Camera_R, 'TriggerMode', 'On')</l>
<l>set_framegrabber_param (Camera_R, 'TriggerSource', 'Line0')</l>
<l>set_framegrabber_param (Camera_R, 'TriggerActivation', 'RisingEdge')</l>
<l>set_framegrabber_param (Camera_R, 'TriggerCacheEnable', 1)</l>
<c></c>
<c></c>
<c></c>
<l>set_framegrabber_param (Camera_L, 'TriggerMode', 'Off')</l>
<l>set_framegrabber_param (Camera_L, 'LineSelector', 'Line2')</l>
<l>set_framegrabber_param (Camera_L, 'LineMode','Strobe')</l>
<l>set_framegrabber_param (Camera_L, 'StrobeEnable', 1)</l>
<l>Image_HDR:=0</l>
<c></c>
<l>if (Image_HDR)</l>
<c>    * Image Acquisition 01: Do something</c>
<l>    ExposureTime_Dark:=1000</l>
<l>    ExposureTime_Bright:=8000</l>
<l>    set_framegrabber_param (Camera_L, 'ExposureTime', ExposureTime_Dark)</l>
<l>    set_framegrabber_param (Camera_R, 'ExposureTime', ExposureTime_Dark)</l>
<l>    par_start &lt;Thread_L&gt; :  grab_image (ImageDark_L, Camera_L)</l>
<l>    par_start&lt;Thread_R&gt; : grab_image (ImageDark_R, Camera_R)</l>
<l>    par_join([Thread_L,Thread_R])</l>
<l>    set_framegrabber_param (Camera_L, 'ExposureTime', ExposureTime_Bright)</l>
<l>    set_framegrabber_param (Camera_R, 'ExposureTime', ExposureTime_Bright)</l>
<l>    par_start &lt;Thread_L&gt; :  grab_image (ImageBright_L, Camera_L)</l>
<l>    par_start&lt;Thread_R&gt; : grab_image (ImageBright_R, Camera_R)</l>
<l>    par_join([Thread_L,Thread_R])</l>
<l>    par_start &lt;Thread_L&gt; : create_hdr_image (ImageDark_L, ImageBright_L, HDRImage_L)</l>
<l>    par_start &lt;Thread_R&gt; : create_hdr_image (ImageDark_R, ImageBright_R, HDRImage_R)</l>
<l>    par_join([Thread_L,Thread_R])</l>
<l>    min_max_gray (HDRImage_L, HDRImage_L, 0, Min, Max, Range)</l>
<l>    scale_image_range (HDRImage_L, ImageScaled, [Min,0], [Max,255])</l>
<l>    convert_image_type (ImageScaled, ImageBack, 'byte')</l>
<c>    </c>
<l>    min_max_gray (HDRImage_R, HDRImage_R, 0, Min, Max, Range)</l>
<l>    scale_image_range (HDRImage_R, ImageScaled, [Min,0], [Max,255])</l>
<l>    convert_image_type (ImageScaled, ImageFront, 'byte')</l>
<l>else</l>
<c>    </c>
<c>    </c>
<c>    </c>
<l>*     while (1)</l>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        </c>
<l>        set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>        set_framegrabber_param (Camera_L, 'StrobeEnable', 1)</l>
<c>        </c>
<l>        set_framegrabber_param (Camera_L, 'BlackLevel', 200)</l>
<l>        set_framegrabber_param (Camera_L, 'ExposureTime', 60000.0)</l>
<l>        set_framegrabber_param (Camera_L, 'Gain', 19)</l>
<l>        set_framegrabber_param (Camera_L, 'Gamma', 0.75)</l>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        </c>
<l>*         par_start &lt;Thread_L&gt; : grab_image_async (ImageFront, Camera_L, -1)</l>
<c>        </c>
<l>*         wait_seconds(0.0)</l>
<l>*         grab_image (ImageFront, Camera_L)</l>
<l>*         par_start &lt;Thread_L&gt; :   grab_image_async (ImageFront, Camera_L, -1)</l>
<l>*         wait_seconds(0.0)</l>
<l>*         par_start &lt;Thread_L&gt; : set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>*         par_start &lt;Thread_L&gt; : set_framegrabber_param (Camera_L, 'StrobeEnable', 1)</l>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        </c>
<l>        set_framegrabber_param (Camera_R, 'LineSelector', 'Line1')</l>
<l>        set_framegrabber_param (Camera_R, 'StrobeEnable', 0)</l>
<l>        set_framegrabber_param (Camera_R, 'BlackLevel', 200)</l>
<l>        set_framegrabber_param (Camera_R, 'ExposureTime', 60000.0)</l>
<l>        set_framegrabber_param (Camera_R, 'Gain', 19)</l>
<l>        set_framegrabber_param (Camera_R, 'Gamma', 0.75)</l>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        </c>
<c>        </c>
<l>        grab_image (ImageFront, Camera_L)</l>
<l>        grab_image_async (ImageBack, Camera_R, -1)</l>
<l>*         par_start&lt;Thread_R&gt; : grab_image (ImageBack, Camera_R)</l>
<l>*         wait_seconds(0.5)</l>
<c>        </c>
<l>*         par_join([Thread_R,Thread_L])</l>
<c>        </c>
<c>        </c>
<l>*         wait_seconds(0)</l>
<c>        </c>
<l>        set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>        set_framegrabber_param (Camera_L, 'BlackLevel', 200)</l>
<l>        set_framegrabber_param (Camera_L, 'ExposureTime', 20000.0)</l>
<l>        set_framegrabber_param (Camera_L, 'Gain', 19)</l>
<l>        set_framegrabber_param (Camera_L, 'Gamma', 0.75)</l>
<l>        set_framegrabber_param (Camera_L, 'StrobeEnable', 0)</l>
<l>        wait_seconds(0.0)</l>
<c>        </c>
<c>        </c>
<l>*         par_start &lt;Thread_L&gt; : set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>*         par_start &lt;Thread_L&gt; : set_framegrabber_param (Camera_L, 'StrobeEnable', 1)</l>
<c>        </c>
<l>        set_framegrabber_param (Camera_R, 'LineSelector', 'Line1')</l>
<l>        set_framegrabber_param (Camera_R, 'BlackLevel', 200)</l>
<l>        set_framegrabber_param (Camera_R, 'ExposureTime', 20000.0)</l>
<l>        set_framegrabber_param (Camera_R, 'Gain', 19)</l>
<l>        set_framegrabber_param (Camera_R, 'Gamma', 0.75)</l>
<l>        set_framegrabber_param (Camera_R, 'StrobeEnable', 1)</l>
<c>        </c>
<c>        </c>
<c>        </c>
<l>*         wait_seconds(0.0)</l>
<l>        grab_image (ImageFront_1, Camera_L)</l>
<l>        grab_image_async (ImageBack_1, Camera_R,-1)</l>
<c>        </c>
<c>        </c>
<c>        </c>
<l>*         par_join([Thread_R,Thread_L])</l>
<c>        </c>
<c>        </c>
<c>        </c>
<l>*         wait_seconds (2)</l>
<l>*         stop()</l>
<l>*     endwhile</l>
<c>    </c>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>count_seconds (Start)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* median_image (ImageFront, ImageFront, 'square', 3, 'mirrored')</l>
<l>* median_image (ImageBack, ImageBack, 'square', 3, 'mirrored')</l>
<l>* read_image (ImageBack,  ImagesBackFiles[21])</l>
<l>* read_image (ImageFront,  ImagesFrontFiles[21])</l>
<l>emphasize (ImageFront_1, Front_1, 100, 100, 8)</l>
<l>emphasize (ImageBack_1, Back_1, 100, 100,8)</l>
<l>concat_obj (Front_1,Back_1, Images_1)</l>
<c></c>
<l>emphasize (ImageFront, Front, 100, 100, 5)</l>
<l>emphasize (ImageBack, Back, 100, 100,5)</l>
<l>concat_obj (Front,Back,  Images)</l>
<c></c>
<c></c>
<c></c>
<l>set_stereo_model_param (StereoModelID, 'binocular_num_levels',2)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_mask_width', 30)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_mask_height',30)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_score_thresh', 0.6)</l>
<l>reconstruct_surface_stereo (Images, StereoModelID, ObjectModel3DScene_1)</l>
<l>get_stereo_model_object (ToImage, StereoModelID, [0, 1], 'to_image_rect')</l>
<l>get_stereo_model_object (FromImage, StereoModelID, [0, 1], 'from_image_rect')</l>
<l>get_stereo_model_object (DisparityImage, StereoModelID, [0, 1], 'disparity_image')</l>
<l>get_stereo_model_object (scoreImage, StereoModelID, [0, 1], 'score_image')</l>
<c></c>
<c></c>
<l>* wait_seconds(0.1)</l>
<c></c>
<l>set_stereo_model_param (StereoModelID, 'binocular_num_levels',3)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_mask_width', 60)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_mask_height',60)</l>
<l>set_stereo_model_param (StereoModelID, 'binocular_score_thresh', 0.3)</l>
<l>reconstruct_surface_stereo (Images_1, StereoModelID, ObjectModel3DScene_2)</l>
<l>get_stereo_model_object (ToImage_1, StereoModelID, [0, 1], 'to_image_rect')</l>
<l>get_stereo_model_object (FromImage_1, StereoModelID, [0, 1], 'from_image_rect')</l>
<l>get_stereo_model_object (DisparityImage_1, StereoModelID, [0, 1], 'disparity_image')</l>
<l>get_stereo_model_object (scoreImage_1, StereoModelID, [0, 1], 'score_image')</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* </c>
<c></c>
<c></c>
<l>* par_join([Surface,GetImage])</l>
<c></c>
<l>wait_seconds(0.0)</l>
<c></c>
<l>View_Unio:=[ObjectModel3DScene_1,ObjectModel3DScene_2]</l>
<c></c>
<c></c>
<l>Image_2D:=ImageFront</l>
<c></c>
<c>* Perform the stereo reconstruction.</c>
<c>* 执行立体重建。</c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>union_object_model_3d (View_Unio, 'points_surface', ObjectModel3DScene)</l>
<c></c>
<c></c>
<c>* 获取3D点云的坐标</c>
<l>* get_object_model_3d_params(ObjectModel3DScene, 'point_coord_x', PointCoordX)</l>
<l>* get_object_model_3d_params(ObjectModel3DScene, 'point_coord_y', PointCoordY)</l>
<l>* get_object_model_3d_params(ObjectModel3DScene, 'point_coord_z', PointCoordZ)</l>
<c></c>
<c>* 应用缩放因子</c>
<l>* PointCoordX := PointCoordX * 1</l>
<l>* PointCoordY := PointCoordY * 1</l>
<l>* PointCoordZ := PointCoordZ * 1</l>
<c></c>
<c>* 更新3D点云的坐标</c>
<l>* set_object_model_3d_attrib_mod (ObjectModel3DScene, ['point_coord_x','point_coord_y','point_coord_z'], [], [PointCoordX,PointCoordY,PointCoordZ])</l>
<c></c>
<c></c>
<l>* write_object_model_3d (ObjectModel3DScene, 'ply', 'C:/Users/zhiwei2.he/Source/repos/We-sson/HanGao/Halcon_SDK/Halcon样图测试/立体视觉/测试点云.dxf', [], [])</l>
<c></c>
<l>* get_stereo_model_object (FromImage, StereoModelID, [0, 1], 'from_image_rect')</l>
<l>* get_stereo_model_object (ToImage, StereoModelID, [0, 1], 'to_image_rect')</l>
<l>* get_stereo_model_object (DisparityImage, StereoModelID, [0, 1], 'disparity_image')</l>
<l>* get_stereo_model_object (DisparityImage, StereoModelID, [0, 1], 'score_image')</l>
<c></c>
<c></c>
<c>*采集主相机正常曝光图像</c>
<l>* set_framegrabber_param (Camera_L, 'StrobeEnable', 0)</l>
<l>* wait_seconds(1)</l>
<l>* set_framegrabber_param (Camera_L, 'LineSelector', 'Line1')</l>
<l>* set_framegrabber_param (Camera_L, 'StrobeEnable', 1)</l>
<l>* set_framegrabber_param (Camera_L, 'BlackLevel', 200)</l>
<l>* set_framegrabber_param (Camera_L, 'ExposureTime', 10000.0)</l>
<l>* set_framegrabber_param (Camera_L, 'Gain', 19)</l>
<l>* set_framegrabber_param (Camera_L, 'Gamma', 0.7)</l>
<c></c>
<l>* grab_image (Image_2D, Camera_L)</l>
<l>* grab_image_async (Image_2D, Camera_L, -1)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* </c>
<c>* Visualize the intermediate results.</c>
<c></c>
<l>* get_image_size (FromImage, WidthFrom, HeightFrom)</l>
<l>* dev_set_window (WindowHandle1)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (FromImage)</l>
<c></c>
<l>* get_image_size (ToImage, WidthTo, HeightTo)</l>
<c></c>
<l>* dev_set_window (WindowHandle2)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (ToImage)</l>
<c></c>
<l>* get_image_size (DisparityImage, Width, Height)</l>
<c></c>
<l>* dev_set_window (WindowHandle3)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (DisparityImage)</l>
<c></c>
<c></c>
<c></c>
<c>*获得点云总数</c>
<l>* get_object_model_3d_params (ObjectModel3DScene, 'num_points', NumPoints)</l>
<c></c>
<c>*点云数据距离进行排序(可选)</c>
<l>* NumNeighbors := 200</l>
<l>* get_object_model_3d_params (ObjectModel3DScene, 'neighbor_distance '+NumNeighbors, DistanceDistribution)</l>
<c></c>
<c>*选择集中距离占比</c>
<l>* InlierRate := 20</l>
<l>* Distance := sort(DistanceDistribution)[|DistanceDistribution| * InlierRate / 100]</l>
<l>* select_points_object_model_3d (ObjectModel3DScene, 'num_neighbors_fast ' + Distance, 12, 'max', OM3DSampledMapping)</l>
<c></c>
<c></c>
<c>*取最小值删除无效数据0(可选)</c>
<l>* select_points_object_model_3d (OM3DSampledMapping, 'num_neighbors_fast 1e-6', 0, 1, OM3DSampledMapping)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*根据点云距离集合分割出</c>
<l>connection_object_model_3d (ObjectModel3DScene, 'distance_3d', 0.001, ObjectModel3DConnected)</l>
<l>select_object_model_3d (ObjectModel3DConnected, 'num_points', 'and', 500, 'max', ObjectModel3DDefect)</l>
<c></c>
<l>union_object_model_3d (ObjectModel3DDefect, 'points_surface', OM3DSampledMapping)</l>
<c></c>
<c></c>
<l>* triangulate_object_model_3d (OM3DSampledMapping, 'xyz_mapping', [], [], TriangulatedDefault, Information0)</l>
<l>* triangulate_object_model_3d (OM3DSampledMapping, 'implicit', ['information','implicit_octree_depth','implicit_solver_depth','implicit_min_num_samples'], ['verbose',12,6,1], Surface3DDefault, Info)</l>
<c></c>
<c></c>
<c></c>
<c>*重采样</c>
<l>* MinNumPoints := 10</l>
<c>*'xyz_mapping'方法按像素距离</c>
<l>SampleDistance := 1</l>
<l>sample_object_model_3d (OM3DSampledMapping, 'xyz_mapping_compute_normals', SampleDistance, [], [], OM3DSampledMapping)</l>
<c>* </c>
<c></c>
<c></c>
<c>*xyz_mapping 用2D平滑方式修正法线</c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'xyz_mapping', ['xyz_mapping_filter'], ['median'], OM3DSampledMapping)</l>
<c></c>
<c></c>
<c>*计算法线统一方向</c>
<l>surface_normals_object_model_3d (OM3DSampledMapping, 'xyz_mapping', [], [], OM3DSampledMapping)</l>
<c></c>
<c></c>
<c></c>
<c>*mls 平滑方法</c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', [], [], ObjectModel3Dsmooth)</l>
<c></c>
<c></c>
<l>smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_kNN', 200, ObjectModel3Dsmooth)</l>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_order', 1, ObjectModel3Dsmooth)</l>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_abs_sigma', 0.1, ObjectModel3Dsmooth)</l>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'mls', 'mls_relative_sigma', 2, ObjectModel3Dsmooth) </l>
<c></c>
<c></c>
<c></c>
<l>* object_model_3d_to_xyz (X, Y, Z, ObjectModel3Dsmooth, 'from_xyz_map', [], [])</l>
<c></c>
<c>*表面三角化</c>
<l>* triangulate_object_model_3d (OM3DSampledSample, 'greedy','greedy_hole_filling', 0.005, TriangulatedObjectModel3D, Information)</l>
<c></c>
<c>*获得深度区域</c>
<l>* get_domain (Z, Z_Reg)</l>
<c>*闭运算消除毛刺</c>
<l>* closing_circle (Z_Reg, RegionClosing, 10)</l>
<l>* closing_rectangle1 (Z_Reg, RegionClosing, 20, 20)</l>
<c></c>
<c>*填充空洞</c>
<l>* fill_up (RegionClosing, Z_Conves)</l>
<c></c>
<c>*区域凸包</c>
<l>* shape_trans (Z, Z_Conves, 'convex')</l>
<c></c>
<c>*区域相差</c>
<l>* difference (Z_Conves, Z, Z_Region)</l>
<c></c>
<l>* full_domain (X, X_Full)</l>
<l>* full_domain (Y, Y_Full)</l>
<l>* full_domain (Z, Z_Full)</l>
<c></c>
<l>* change_domain (X_Full, Z_Conves, X_Domain)</l>
<l>* change_domain (Y_Full, Z_Conves, Y_Domain)</l>
<l>* change_domain (Z_Full, Z_Conves, Z_Domain)</l>
<c></c>
<c></c>
<c>*线性修复</c>
<l>* harmonic_interpolation (X_Domain, Z_Region, X_interpolation, 0.00001)</l>
<l>* harmonic_interpolation (Y_Domain, Z_Region, Y_interpolation, 0.00001)</l>
<l>* harmonic_interpolation (Z_Domain, Z_Region, Z_interpolation, 0.00001)</l>
<c></c>
<l>* inpainting_ct (X_interpolation, Z_Region, X_Harmonic, 10, 25, 10, 0.1, 1)</l>
<l>* inpainting_ct (Y_interpolation, Z_Region, Y_Harmonic,20, 25, 1, 1, 1)</l>
<l>* inpainting_ct (Z_interpolation, Z_Region, Z_Harmonic, 20, 25, 1, 1, 1)</l>
<c></c>
<c></c>
<l>* inpainting_ced (X_interpolation, Z_Region, X_Harmonic, 3, 1, 5, 300)</l>
<l>* inpainting_ced (Y_interpolation, Z_Region, Y_Harmonic, 3, 1, 5, 300)</l>
<l>* inpainting_ced (Z_interpolation, Z_Region, Z_Harmonic, 3, 1, 5, 300)</l>
<c></c>
<l>* inpainting_mcf (X_interpolation, Z_Region, X_Harmonic, 10, 0.1, 100)</l>
<l>* inpainting_mcf (Y_interpolation, Z_Region, Y_Harmonic,10, 0.5, 100)</l>
<l>* inpainting_mcf (Z_interpolation, Z_Region, Z_Harmonic, 10, 0.5, 100)</l>
<c></c>
<l>* inpainting_texture (X_interpolation, Z_Region, X_Harmonic,11, 40, 0, 'none', 0)</l>
<l>* inpainting_texture (Y_interpolation, Z_Region, Y_Harmonic, 9, 30, 1, 'none', 0.1)</l>
<l>* inpainting_texture (Z_interpolation, Z_Region, Z_Harmonic, 9, 30, 1, 'none', 0.1)</l>
<c></c>
<l>* inpainting_aniso (X_Domain, Z_Region, X_Harmonic,'shock', 5, 5, 60, 1)</l>
<l>* inpainting_aniso (Y_Domain, Z_Region, Y_Harmonic,'shock', 5, 5, 60, 1)</l>
<l>* inpainting_aniso (Z_Domain, Z_Region, Z_Harmonic,'shock', 5, 5, 60, 1)</l>
<c></c>
<c></c>
<l>* xyz_to_object_model_3d (X_Harmonic, Y_Harmonic, Z_Harmonic, ObjectModel3D)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* smooth_object_model_3d (OM3DSampledMapping, 'xyz_mapping_compute_normals', ['xyz_mapping_mask_width','xyz_mapping_mask_height'], [5,5], ObjectModel3Dsmooth)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* 'greedy_kNN' --&gt; 40</c>
<c>* 'greedy_radius_type' --&gt; 'auto'</c>
<c>* 'greedy_radius_value' --&gt; 1.0</c>
<c>* 'greedy_neigh_orient_tol' --&gt; 30</c>
<c>* 'greedy_neigh_orient_consistent' --&gt; 'false'</c>
<c>* 'greedy_neigh_vertical_tol' --&gt; 0.1</c>
<c>* 'greedy_neigh_latitude_tol' --&gt; 30</c>
<c>* 'greedy_hole_filling' --&gt; 40</c>
<c>* 'greedy_fix_flips' --&gt; 'true'</c>
<c>* 'greedy_mesh_erosion' --&gt; 0</c>
<c>* 'greedy_mesh_dilation' --&gt; 0</c>
<c>* 'greedy_remove_small_surfaces' --&gt; 'false'</c>
<c>* 'greedy_prefetch_neighbors' --&gt; 'true'</c>
<c>* 'greedy_timeout' --&gt; 'false'</c>
<c>* 'greedy_suppress_timeout_error' --&gt; 'false'</c>
<c>* 'information' --&gt; 'num_triangles'</c>
<c></c>
<c></c>
<l>ParameterNames := ['information','greedy_kNN','greedy_radius_type','greedy_radius_value','greedy_neigh_orient_tol','greedy_neigh_orient_consistent','greedy_neigh_latitude_tol','greedy_neigh_vertical_tol','greedy_hole_filling','greedy_fix_flips','greedy_prefetch_neighbors','greedy_mesh_erosion','greedy_mesh_dilation']</l>
<l>ParameterValues := ['verbose',20,'fixed',0.0055,200,'false',100,0.1,1000000,'true','true',5,1]</l>
<c></c>
<c>*三角化预生产，减少计算时间</c>
<l>prepare_object_model_3d (ObjectModel3Dsmooth, 'segmentation', 'true', ['max_area_holes'], [1000000])</l>
<c>*测量三角化计算</c>
<l>triangulate_object_model_3d (ObjectModel3Dsmooth, 'greedy', ParameterNames , ParameterValues, Surface3DDefault, Info)</l>
<c></c>
<l>* triangulate_object_model_3d (ObjectModel3Dsmooth, 'polygon_triangulation', [], [], TriangulatedObjectModel3D, Information)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*反转点云位置</c>
<l>pose_invert (CamSetupModel_Pos, Pos_CamInObj)</l>
<l>* sample_object_model_3d (Surface3DDefault, 'accurate_use_normals', 0.0002, [], [], OM3DSampledMapping)</l>
<c></c>
<l>* triangulate_object_model_3d (ObjectModel3Dsmooth, 'greedy', [], [], TriangulatedObjectModel3D, Information)</l>
<c></c>
<c></c>
<c></c>
<l>object_model_3d_to_xyz (X, Y, Z, Surface3DDefault, 'cartesian_faces', CamParamLeft, Pos_CamInObj)</l>
<c></c>
<l>* object_model_3d_to_xyz (X_O, Y_O, Z_O, Surface3DDefault, 'from_xyz_map', [], [])</l>
<c></c>
<l>* get_image_size (FromImage, Width, Height)</l>
<l>* zoom_image_size (X_O, X_O_Zoom, Width, Height, 'nearest_neighbor')</l>
<l>* zoom_image_size (Y_O, Y_O_Zoom, Width, Height, 'nearest_neighbor')</l>
<l>* zoom_image_size (Z_O, Z_O_Zoom, Width, Height, 'nearest_neighbor')</l>
<l>* compose3 (X_O_Zoom, Y_O_Zoom, Z_O_Zoom, XYZ_Zoom)</l>
<c></c>
<c></c>
<l>compose3 (X, Y, Z, XYZImage)</l>
<c></c>
<c></c>
<l>* erosion_circle (X,X_1 , 30)</l>
<l>* erosion_circle (Y, Y_1, 30)</l>
<l>* erosion_circle (Z, Z_1, 30)</l>
<c></c>
<l>* reduce_domain (X, X_1, X_Roi)</l>
<l>* reduce_domain (Y, Y_1, Y_Roi)</l>
<l>* reduce_domain (Z, X_1, Z_Roi)</l>
<c></c>
<c></c>
<c></c>
<l>* xyz_attrib_to_object_model_3d (X_Roi, Y_Roi, Z_Roi, Front, '&amp;amp;gray', ObjectModel3D1)</l>
<c></c>
<c></c>
<l>* xyz_attrib_to_object_model_3d (X_1, Y_1, Z_1, Front, '&amp;amp;gray', ObjectModel3D)</l>
<c></c>
<l>* get_domain (Z, Domain)</l>
<c></c>
<c>*设置点云颜色</c>
<l>object_model_3d_to_xyz (I_X, I_Y, I_Z, Surface3DDefault, 'from_xyz_map', [], [])</l>
<l>get_image_size (I_X, Width, Height)</l>
<l>zoom_image_size (FromImage, ImageZoom, Width, Height, 'nearest_neighbor')</l>
<l>get_domain (I_Z, Domain)</l>
<l>get_region_points (Domain, Rows, Columns)</l>
<l>get_grayval (ImageZoom, Rows, Columns, AttribValues)</l>
<c>* Set the gray values as attributes of the 3D object model.</c>
<l>remove_object_model_3d_attrib (Surface3DDefault, ['red','green','blue'], Surface3DDefault)</l>
<l>set_object_model_3d_attrib_mod (Surface3DDefault, '&amp;gray', 'points', AttribValues)</l>
<c></c>
<c></c>
<c></c>
<l>* object_model_3d_to_xyz (X2, Y2, Z2, ObjectModel3Dsmooth, 'from_xyz_map', [], [])</l>
<c></c>
<c>*缩放深度图到图像大小</c>
<l>* get_image_size (ImageFront, Width1, Height1)</l>
<l>* zoom_image_size (Z1, ImageZoom, Width1/2, Height1/2, 'constant')</l>
<l>* zoom_image_size (ImageFront, ImageFrontZoom, Width1/2, Height1/2, 'constant')</l>
<l>* zoom_image_size (ImageFront, ImageFrontZoom, Width1, Height1, 'nearest_neighbor')</l>
<l>count_seconds (End)</l>
<l>TimeDefault := End - Start</l>
<c></c>
<l>* dev_display (Image_2D)</l>
<l>* dev_display (Z)</l>
<c></c>
<l>Info:= [ '耗时：'+TimeDefault+'秒']</l>
<c></c>
<l>* wait_seconds (1)</l>
<l>* dev_clear_window ()</l>
<l>* dev_display (ImageZoom)</l>
<l>* sample_object_model_3d (ObjectModel3DScene, 'furthest_point_compute_normals',1, [], [], OM3DSampledMapping)</l>
<c></c>
<l>* sample_object_model_3d (ObjectModel3DScene, 'accurate',0.0001, ['min_num_points'], [210], OM3DSampledMapping)</l>
<c></c>
<c></c>
<c></c>
<l>* connection_object_model_3d (ObjectModel3DScene, 'distance_3d',0.006, ObjectModel3DConnected)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* stop ()</l>
<c>* </c>
<c>* Visualize the stereo reconstruction.</c>
<l>* visualize_object_model_3d (WindowHandle3, ObjectModel3DScene, [], [], [],[], '3D reconstruction with projected gray values', [], [], VisPose)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="Union_Two_Camera">
<parameters>
<parameter id="CamSetupModel">
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Camera_L">
<mixed_type>false</mixed_type>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Camera_R">
<mixed_type>false</mixed_type>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image_2D">
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Info">
<sem_type>string</sem_type>
</parameter>
<parameter id="StereoModelID">
<mixed_type>false</mixed_type>
<sem_type>stereo_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Surface3DDefault">
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="X">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Y">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Z">
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
</hdevelop>
